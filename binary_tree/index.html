<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>App Visualizador AVL Avan√ßado (Cen√°rios Aleat√≥rios)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .node { background-color: #3b82f6; color: white; border-radius: 50%; width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; font-weight: bold; position: absolute; border: 2px solid #1e40af; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: all 0.3s ease-in-out; font-size: 0.9rem; cursor: default; z-index: 10; }
        .node.highlight-unbalanced { border-color: #f59e0b; box-shadow: 0 0 15px #f59e0b, 0 0 20px #fde68a; background-color: #d97706; }
        .node-value { font-size: 1rem; }
        .node-height { position: absolute; bottom: -20px; font-size: 0.7rem; color: #4b5563; }
        .node-bf { position: absolute; top: -20px; font-size: 0.7rem; color: #16a34a; font-weight: bold; }
        #tree-container { position: relative; width: 100%; min-height: 450px; overflow: auto; border: 1px solid #d1d5db; background-color: white; border-radius: 0.5rem; margin-top: 1rem; padding: 1rem; }
        #message-log { background-color: #e5e7eb; border-radius: 0.5rem; padding: 0.75rem; margin-top: 1rem; max-height: 180px; overflow-y: auto; font-size: 0.875rem; color: #374151; border: 1px solid #d1d5db; }
        .log-entry { padding: 0.3rem 0.1rem; border-bottom: 1px solid #d1d5db; }
        .log-entry:last-child { border-bottom: none; }
        .line { stroke: #9ca3af; stroke-width: 2; position: absolute; top: 0; left: 0; z-index: 0; }
        .control-btn { padding: 0.6rem 1.2rem; color: white; font-weight: 500; border-radius: 0.375rem; transition: background-color 0.2s ease-in-out, transform 0.1s ease; margin-top: 0.25rem; margin-bottom: 0.25rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .control-btn:hover { opacity: 0.9; transform: translateY(-1px); }
        .control-btn:active { transform: translateY(0px); }
        #explanation-box, #bst-explanation-box, #rotation-wiki, .wiki-example-display { white-space: pre-wrap; word-wrap: break-word; }
        .wiki-section { margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px dashed #cbd5e1; }
        .wiki-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0;}
        .code-like { font-family: 'Courier New', Courier, monospace; background-color: #eef2ff; padding: 0.1rem 0.3rem; border-radius: 0.2rem; font-size: 0.9em; color: #4338ca; }
        .example-btn { background-color: #10b981; padding: 0.4rem 0.8rem; font-size: 0.875rem; margin-top:0.5rem; }
        .example-btn:hover { background-color: #059669; }
        .wiki-example-display { margin-top: 0.75rem; padding: 0.75rem; background-color: #f0f9ff; border: 1px solid #bae6fd; border-radius: 0.375rem; font-size: 0.9em; }
        input[type="number"], .std-btn { padding: 0.75rem; border-radius: 0.375rem; border: 1px solid #d1d5db; margin-right: 0.5rem; transition: all 0.2s ease-in-out; }
        input[type="number"]:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59,130,246,0.3); }
        .std-btn { background-color: #3b82f6; color: white; font-weight: 600; }
        .std-btn:hover { background-color: #2563eb; }
        .std-btn:disabled, .control-btn:disabled { background-color: #9ca3af; cursor: not-allowed; opacity: 0.6; box-shadow: none; transform: none;}
        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2563eb; }
        input:focus + .slider { box-shadow: 0 0 1px #2563eb; }
        input:checked + .slider:before { transform: translateX(26px); }
        .scenario-btn { background-color: #fb923c; /* Tailwind orange-400 */ }
        .scenario-btn:hover { background-color: #f97316; /* Tailwind orange-500 */ }
    </style>
</head>
<body class="p-4 md:p-6 bg-slate-100">
    <div class="max-w-5xl mx-auto bg-white p-5 md:p-8 rounded-xl shadow-2xl">
        <header class="text-center mb-6 pb-4 border-b border-slate-200">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800">Visualizador AVL Avan√ßado üß†</h1>
            <p class="text-gray-600 mt-1">Sua ferramenta de estudo interativa para √Årvores AVL!</p>
        </header>

        <section class="mb-6">
            <div class="flex flex-col sm:flex-row items-center justify-center gap-2">
                <input type="number" id="node-value" placeholder="Valor do n√≥" class="mb-2 sm:mb-0 flex-grow sm:flex-grow-0 w-full sm:w-auto">
                <button id="insert-btn" class="std-btn w-full sm:w-auto control-btn">‚ûï Inserir N√≥</button>
                <button id="remove-btn" class="std-btn w-full sm:w-auto control-btn bg-red-500 hover:bg-red-600">‚ûñ Remover N√≥</button>
            </div>
        </section>

        <section class="mb-6 p-4 bg-slate-100 rounded-lg shadow-md">
            <div class="flex flex-col sm:flex-row justify-between items-center gap-4">
                <div class="flex items-center">
                    <label class="switch mr-3">
                        <input type="checkbox" id="auto-balance-toggle">
                        <span class="slider"></span>
                    </label>
                    <span id="mode-status-text" class="font-medium text-gray-700 whitespace-nowrap">Modo: Balanceamento Manual</span>
                </div>
                <button id="wiki-toggle-btn" class="control-btn bg-teal-500 hover:bg-teal-600 w-full sm:w-auto">üìñ Ajuda Rota√ß√µes AVL (Wiki)</button>
            </div>
            <button id="check-balance-btn" class="control-btn mt-3 w-full bg-indigo-500 hover:bg-indigo-600">
                üõ†Ô∏è Verificar Balanceamento e Ativar Modo Manual
            </button>
        </section>

        <section class="mb-6 p-4 bg-slate-100 rounded-lg shadow-md">
            <h3 class="text-lg font-semibold text-gray-700 mb-3 text-center">Gerar Cen√°rios de Desbalanceamento para Pr√°tica:</h3>
            <div class="flex justify-center">
                <button id="gen-random-scenario-btn" class="control-btn scenario-btn w-full md:w-1/2 lg:w-1/3 bg-purple-500 hover:bg-purple-600">üé≤ Gerar Cen√°rio Aleat√≥rio</button>
            </div>
        </section>

        <div id="bst-explanation-box" class="mb-4 p-4 bg-green-50 border border-green-300 rounded-lg text-sm text-green-800 shadow-sm" style="display: none;">
             <h4 class="font-semibold text-md mb-2 text-green-700">üßê Explica√ß√£o da Inser√ß√£o (Regras BST):</h4>
             <p id="bst-explanation-content"></p>
        </div>

        <div id="manual-rotation-controls" class="mt-4 p-4 border-2 border-amber-500 rounded-lg bg-amber-50 shadow-md" style="display: none;">
            <h3 class="text-lg font-semibold text-amber-700">‚ö†Ô∏è Balanceamento Manual Necess√°rio!</h3>
            <p id="manual-balance-message" class="text-amber-600 mb-3">O n√≥ destacado precisa ser balanceado.</p>
            <div class="text-sm mb-3 space-y-1">
                <p>N√≥ a balancear: <span id="manual-node-value-info" class="font-bold text-amber-800"></span></p>
                <p>FB do N√≥: <span id="manual-node-bf-info" class="font-bold text-amber-800"></span></p>
                <p>FB do Filho Relevante: <span id="manual-node-child-bf-info" class="font-bold text-amber-800"></span></p>
            </div>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-2 mb-3">
                <button id="manual-srr" data-rotation="SRR" class="control-btn manual-rot-btn bg-orange-500 hover:bg-orange-600 w-full">Rot. Simples Direita</button>
                <button id="manual-slr" data-rotation="SLR" class="control-btn manual-rot-btn bg-orange-500 hover:bg-orange-600 w-full">Rot. Simples Esquerda</button>
                <button id="manual-dlr" data-rotation="DLR" class="control-btn manual-rot-btn bg-orange-500 hover:bg-orange-600 w-full">Rot. Dupla Esq-Dir</button>
                <button id="manual-drl" data-rotation="DRL" class="control-btn manual-rot-btn bg-orange-500 hover:bg-orange-600 w-full">Rot. Dupla Dir-Esq</button>
            </div>
            <div class="flex flex-col sm:flex-row gap-2">
                <button id="show-explanation-btn" class="control-btn w-full sm:w-1/2 bg-sky-500 hover:bg-sky-600">üí° Ver Solu√ß√£o AVL</button>
                <button id="auto-balance-one-btn" class="control-btn w-full sm:w-1/2 bg-green-600 hover:bg-green-700">ü§ñ App Balanceia Este N√≥</button>
            </div>
            <div id="explanation-box" class="mt-4 p-3 bg-blue-50 border border-blue-300 rounded-lg text-sm text-blue-800 shadow-sm" style="display: none;">
            </div>
        </div>

        <div id="rotation-wiki" class="my-6 p-5 border border-gray-300 rounded-lg bg-gray-50 shadow-lg" style="display: none;">
            <h3 class="text-xl font-semibold text-gray-800 mb-4 border-b pb-3">üìñ Mini-Wiki: Rota√ß√µes em √Årvores AVL</h3>

            <div class="wiki-section">
                <h4 class="text-lg font-semibold text-indigo-700 mb-2">Entendendo o Fator de Balanceamento (FB)</h4>
                <p class="text-sm text-gray-700">O Fator de Balanceamento de um n√≥ √© crucial para √°rvores AVL. Ele determina se uma sub√°rvore est√° balanceada ou n√£o.</p>
                <p class="text-sm text-gray-700 my-2 p-2 bg-indigo-50 rounded-md">√â calculado como: <strong class="code-like">FB = Altura(Sub√°rvore Esquerda) - Altura(Sub√°rvore Direita)</strong></p>
                <p class="text-sm text-gray-700 mb-1">Lembretes importantes:</p>
                <ul class="list-disc list-inside text-sm text-gray-700 space-y-1 pl-2 mb-2">
                    <li>A <strong class="code-like">altura de um n√≥ folha</strong> (um n√≥ sem filhos) √© <strong class="code-like">0</strong>.</li>
                    <li>A <strong class="code-like">altura de um n√≥ nulo</strong> (aus√™ncia de um filho) √© <strong class="code-like">-1</strong>. Esta conven√ß√£o simplifica os c√°lculos.</li>
                </ul>
                <p class="text-sm text-gray-700 mb-1">Significado dos valores de FB:</p>
                 <ul class="list-disc list-inside text-sm text-gray-700 space-y-1 pl-2">
                    <li><strong class="text-green-600 code-like">FB = 0:</strong> O n√≥ est√° perfeitamente balanceado (alturas das sub√°rvores s√£o iguais).</li>
                    <li><strong class="text-green-600 code-like">FB = +1:</strong> A sub√°rvore esquerda √© uma unidade mais alta. O n√≥ ainda √© considerado balanceado.</li>
                    <li><strong class="text-green-600 code-like">FB = -1:</strong> A sub√°rvore direita √© uma unidade mais alta. O n√≥ ainda √© considerado balanceado.</li>
                    <li><strong class="text-red-600 code-like">FB = +2 (ou mais):</strong> O n√≥ est√° desbalanceado, "pesado" √† esquerda. <span class="font-semibold">Precisa de rota√ß√£o!</span></li>
                    <li><strong class="text-red-600 code-like">FB = -2 (ou menos):</strong> O n√≥ est√° desbalanceado, "pesado" √† direita. <span class="font-semibold">Precisa de rota√ß√£o!</span></li>
                </ul>
            </div>

            <div class="wiki-section">
                <h4 class="text-lg font-semibold text-sky-700">‚û°Ô∏è Rota√ß√£o Simples √† Direita (SRR)</h4>
                <p class="text-sm text-gray-700 mt-1"><strong>Quando:</strong> O n√≥ Pai (<span class="code-like">P</span>) est√° desbalanceado com <strong class="code-like">FB(P) = +2</strong> E seu Filho Esquerdo (<span class="code-like">FE</span>) tem <strong class="code-like">FB(FE) = +1 ou 0</strong>.</p>
                <p class="text-sm text-gray-700"><strong>Caso:</strong> Esquerda-Esquerda (LL).</p>
                <p class="text-sm text-gray-700"><strong>A√ß√£o:</strong> <span class="code-like">FE</span> sobe e se torna a nova raiz da sub√°rvore. <span class="code-like">P</span> desce e se torna o filho direito de <span class="code-like">FE</span>. O antigo filho direito de <span class="code-like">FE</span> (se existir, <span class="code-like">T2</span>) se torna o novo filho esquerdo de <span class="code-like">P</span>.</p>
                <button class="control-btn example-btn wiki-example-generator" data-rotation-type="SRR">üìù Gerar Exemplo Num√©rico e Explica√ß√£o</button>
                <div class="wiki-example-display" id="wiki-srr-example"></div>
            </div>

            <div class="wiki-section">
                <h4 class="text-lg font-semibold text-sky-700">‚¨ÖÔ∏è Rota√ß√£o Simples √† Esquerda (SLR)</h4>
                <p class="text-sm text-gray-700 mt-1"><strong>Quando:</strong> O n√≥ Pai (<span class="code-like">P</span>) est√° desbalanceado com <strong class="code-like">FB(P) = -2</strong> E seu Filho Direito (<span class="code-like">FD</span>) tem <strong class="code-like">FB(FD) = -1 ou 0</strong>.</p>
                <p class="text-sm text-gray-700"><strong>Caso:</strong> Direita-Direita (RR).</p>
                <p class="text-sm text-gray-700"><strong>A√ß√£o:</strong> <span class="code-like">FD</span> sobe e se torna a nova raiz. <span class="code-like">P</span> desce e se torna o filho esquerdo de <span class="code-like">FD</span>. O antigo filho esquerdo de <span class="code-like">FD</span> (se existir, <span class="code-like">T2</span>) se torna o novo filho direito de <span class="code-like">P</span>.</p>
                <button class="control-btn example-btn wiki-example-generator" data-rotation-type="SLR">üìù Gerar Exemplo Num√©rico e Explica√ß√£o</button>
                <div class="wiki-example-display" id="wiki-slr-example"></div>
            </div>

            <div class="wiki-section">
                <h4 class="text-lg font-semibold text-sky-700">‚Ü™Ô∏è Rota√ß√£o Dupla Esquerda-Direita (DLR)</h4>
                <p class="text-sm text-gray-700 mt-1"><strong>Quando:</strong> O n√≥ Pai (<span class="code-like">P</span>) est√° desbalanceado com <strong class="code-like">FB(P) = +2</strong> E seu Filho Esquerdo (<span class="code-like">FE</span>) tem <strong class="code-like">FB(FE) = -1</strong> (pesado √† direita).</p>
                <p class="text-sm text-gray-700"><strong>Caso:</strong> Esquerda-Direita (LR) - um "zig-zag".</p>
                <p class="text-sm text-gray-700"><strong>A√ß√£o (2 passos):</strong></p>
                <ol class="list-decimal list-inside text-sm text-gray-700 pl-2 space-y-1">
                    <li><strong>Rota√ß√£o Simples √† Esquerda em <span class="code-like">FE</span>:</strong> O neto (<span class="code-like">N</span>), que √© filho direito de <span class="code-like">FE</span>, sobe. <span class="code-like">FE</span> se torna filho esquerdo de <span class="code-like">N</span>. Isso transforma o caso LR em um caso LL (visto da perspectiva de <span class="code-like">P</span>).</li>
                    <li><strong>Rota√ß√£o Simples √† Direita em <span class="code-like">P</span>:</strong> Agora que √© um caso LL, aplica-se SRR em <span class="code-like">P</span>. O n√≥ <span class="code-like">N</span> (que subiu no passo 1) se torna a raiz final da sub√°rvore.</li>
                </ol>
                <button class="control-btn example-btn wiki-example-generator" data-rotation-type="DLR">üìù Gerar Exemplo Num√©rico e Explica√ß√£o</button>
                <div class="wiki-example-display" id="wiki-dlr-example"></div>
            </div>

            <div> <h4 class="text-lg font-semibold text-sky-700">‚Ü©Ô∏è Rota√ß√£o Dupla Direita-Esquerda (DRL)</h4>
                <p class="text-sm text-gray-700 mt-1"><strong>Quando:</strong> O n√≥ Pai (<span class="code-like">P</span>) est√° desbalanceado com <strong class="code-like">FB(P) = -2</strong> E seu Filho Direito (<span class="code-like">FD</span>) tem <strong class="code-like">FB(FD) = +1</strong> (pesado √† esquerda).</p>
                <p class="text-sm text-gray-700"><strong>Caso:</strong> Direita-Esquerda (RL) - um "zig-zag".</p>
                <p class="text-sm text-gray-700"><strong>A√ß√£o (2 passos):</strong></p>
                 <ol class="list-decimal list-inside text-sm text-gray-700 pl-2 space-y-1">
                    <li><strong>Rota√ß√£o Simples √† Direita em <span class="code-like">FD</span>:</strong> O neto (<span class="code-like">N</span>), que √© filho esquerdo de <span class="code-like">FD</span>, sobe. <span class="code-like">FD</span> se torna filho direito de <span class="code-like">N</span>. Isso transforma o caso RL em um caso RR (visto da perspectiva de <span class="code-like">P</span>).</li>
                    <li><strong>Rota√ß√£o Simples √† Esquerda em <span class="code-like">P</span>:</strong> Agora que √© um caso RR, aplica-se SLR em <span class="code-like">P</span>. O n√≥ <span class="code-like">N</span> se torna a raiz final.</li>
                </ol>
                <button class="control-btn example-btn wiki-example-generator" data-rotation-type="DRL">üìù Gerar Exemplo Num√©rico e Explica√ß√£o</button>
                <div class="wiki-example-display" id="wiki-drl-example"></div>
            </div>
        </div>

        <p class="text-sm text-gray-600 text-center my-3">Legenda: <span class="text-green-600 font-semibold">BF</span> (Fator de Balanceamento), <span class="text-gray-600 font-semibold">H</span> (Altura)</p>
        <div id="tree-container">
            <svg id="tree-svg" width="100%" height="100%" style="position: absolute; top: 0; left: 0; pointer-events: none;"></svg>
        </div>

        <div id="message-log-container" class="mt-6">
            <h2 class="text-xl font-semibold text-gray-700 mb-2">Log de Opera√ß√µes:</h2>
            <div id="message-log">
                <div class="log-entry">Bem-vindo! Escolha o modo de balanceamento e comece a operar.</div>
            </div>
        </div>
    </div>

    <script>
        class Node {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.height = 0;
                this.x = 0; this.y = 0; this.element = null;
            }
        }

        class AVLTree {
            constructor() {
                this.root = null;
                this.messageLog = [];
                this.logLimit = 30;
                this.manualBalancingInfo = { isActive: false, nodeToBalance: null, parentNode: null, isLeftChild: false, expectedRotation: null, balanceFactor: 0, childBalanceFactor: 0 };
                this.autoBalanceEnabled = false;
                this.bstInsertionPath = [];
            }

            log(message) {
                this.messageLog.unshift(message);
                if (this.messageLog.length > this.logLimit) this.messageLog.pop();
                this.updateMessageLogUI();
            }

            updateMessageLogUI() {
                const logContainer = document.getElementById('message-log');
                if (!logContainer) return;
                logContainer.innerHTML = '';
                [...this.messageLog].forEach(msg => {
                    const entry = document.createElement('div');
                    entry.className = 'log-entry';
                    entry.textContent = msg;
                    logContainer.appendChild(entry);
                });
                logContainer.scrollTop = 0;
            }

            getHeight(node) { return node ? node.height : -1; }
            updateHeight(node) { if (node) node.height = 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right)); }
            getBalanceFactor(node) { return node ? this.getHeight(node.left) - this.getHeight(node.right) : 0; }

            rightRotate(y) {
                const x = y.left;
                const T2 = x.right;
                x.right = y; y.left = T2;
                this.updateHeight(y); this.updateHeight(x);
                return x;
            }

            leftRotate(x) {
                const y = x.right;
                const T2 = y.left;
                y.left = x; x.right = T2;
                this.updateHeight(x); this.updateHeight(y);
                return y;
            }

            insert(value) {
                this.bstInsertionPath = [{type: 'start', value: value}];
                this.log(`‚û°Ô∏è Tentando inserir ${value}...`);
                this.root = this._insertNodeRecursive(this.root, value);

                const isDuplicate = this.bstInsertionPath.some(s => s.type === 'duplicate');
                if (!isDuplicate || !this.autoBalanceEnabled) {
                    this.displayBstInsertionExplanation(value);
                } else {
                     const bstBox = document.getElementById('bst-explanation-box');
                     if (bstBox) bstBox.style.display = 'none';
                }

                if (this.autoBalanceEnabled && !isDuplicate) {
                    this.log("‚öôÔ∏è Modo Autom√°tico: Balanceamento AVL p√≥s-inser√ß√£o conclu√≠do (se necess√°rio).");
                } else if (!isDuplicate) {
                    this.log(`‚úÖ N√≥ ${value} inserido (BST). Clique em "üõ†Ô∏è Verificar Balanceamento" para modo manual.`);
                }
                this.updateAllHeights(this.root);
                this.visualize();
            }

            _insertNodeRecursive(node, value) {
                if (!node) {
                    this.bstInsertionPath.push({ type: 'found_spot', valueToInsert: value });
                    return new Node(value);
                }

                this.bstInsertionPath.push({ type: 'compare', nodeValue: node.value, valueToInsert: value });
                if (value < node.value) {
                    this.bstInsertionPath.push({ type: 'go_left', parentValue: node.value, valueToInsert: value });
                    node.left = this._insertNodeRecursive(node.left, value);
                } else if (value > node.value) {
                    this.bstInsertionPath.push({ type: 'go_right', parentValue: node.value, valueToInsert: value });
                    node.right = this._insertNodeRecursive(node.right, value);
                } else {
                    this.bstInsertionPath.push({ type: 'duplicate', nodeValue: node.value, valueToInsert: value });
                    this.log(`‚ö†Ô∏è Valor ${value} j√° existe na √°rvore (no n√≥ ${node.value}).`);
                    return node;
                }

                this.updateHeight(node);

                if (this.autoBalanceEnabled) {
                    const balance = this.getBalanceFactor(node);
                    if (balance > 1 && this.getBalanceFactor(node.left) >= 0) {
                        this.log(`‚öôÔ∏è AUTO-BALANCE: Rota√ß√£o Simples √† Direita no n√≥ ${node.value} (Caso LL)`);
                        return this.rightRotate(node);
                    }
                    if (balance < -1 && this.getBalanceFactor(node.right) <= 0) {
                        this.log(`‚öôÔ∏è AUTO-BALANCE: Rota√ß√£o Simples √† Esquerda no n√≥ ${node.value} (Caso RR)`);
                        return this.leftRotate(node);
                    }
                    if (balance > 1 && this.getBalanceFactor(node.left) < 0) {
                        this.log(`‚öôÔ∏è AUTO-BALANCE: Rota√ß√£o Dupla Esq-Dir no n√≥ ${node.value} (Caso LR)`);
                        node.left = this.leftRotate(node.left);
                        return this.rightRotate(node);
                    }
                    if (balance < -1 && this.getBalanceFactor(node.right) > 0) {
                        this.log(`‚öôÔ∏è AUTO-BALANCE: Rota√ß√£o Dupla Dir-Esq no n√≥ ${node.value} (Caso RL)`);
                        node.right = this.rightRotate(node.right);
                        return this.leftRotate(node);
                    }
                }
                return node;
            }

            displayBstInsertionExplanation(insertedValue) {
                const box = document.getElementById('bst-explanation-box');
                const contentP = document.getElementById('bst-explanation-content');
                if (!box || !contentP) return;

                let expl = `Para inserir o valor "${insertedValue}":\n\n`;

                if (this.bstInsertionPath.length === 1 && this.bstInsertionPath[0].type === 'start' && !this.root) {
                     expl += `-> √Årvore estava vazia. N√≥ "${insertedValue}" se torna a raiz.\n`;
                } else if (this.bstInsertionPath.length > 0 && this.bstInsertionPath[0].type === 'start' && this.bstInsertionPath.length === 1 && this.root && this.root.value === insertedValue) {
                     expl += `-> √Årvore estava vazia. N√≥ "${insertedValue}" se torna a raiz.\n`;
                } else {
                    for (const step of this.bstInsertionPath) {
                        if (step.type === 'compare') {
                            expl += `-> No n√≥ "${step.nodeValue}": Comparamos "${step.valueToInsert}" com "${step.nodeValue}".\n`;
                        } else if (step.type === 'go_left') {
                            expl += `   Como "${step.valueToInsert}" < "${step.parentValue}", vamos para a ESQUERDA.\n`;
                        } else if (step.type === 'go_right') {
                            expl += `   Como "${step.valueToInsert}" > "${step.parentValue}", vamos para a DIREITA.\n`;
                        } else if (step.type === 'found_spot') {
                            expl += `-> Encontramos um local vazio e inserimos "${step.valueToInsert}" ali.\n`;
                        } else if (step.type === 'duplicate') {
                            expl += `-> O valor "${step.valueToInsert}" j√° existe na √°rvore (no n√≥ "${step.nodeValue}"). Inser√ß√£o ignorada.\n`;
                            break;
                        }
                    }
                }
                expl += "\nInser√ß√£o BST (posicionamento inicial) conclu√≠da.";
                contentP.textContent = expl;
                box.style.display = 'block';
            }

            delete(value) {
                this.log(`üóëÔ∏è Tentando remover ${value}...`);
                this.root = this._deleteNodeRecursive(this.root, value);
                 if (this.autoBalanceEnabled) {
                    this.log("‚öôÔ∏è Modo Autom√°tico: Balanceamento AVL p√≥s-remo√ß√£o conclu√≠do (se necess√°rio).");
                } else {
                    this.log(`‚úÖ Remo√ß√£o de ${value} tentada (BST). Clique em "üõ†Ô∏è Verificar Balanceamento".`);
                }
                this.updateAllHeights(this.root);
                this.visualize();
                const bstBox = document.getElementById('bst-explanation-box');
                if(bstBox) bstBox.style.display = 'none';
            }

            _maxValueNode(node) {
                let current = node;
                while (current && current.right) current = current.right;
                return current;
            }

            _deleteNodeRecursive(node, value) {
                if (!node) { this.log(`‚ö†Ô∏è Valor ${value} n√£o encontrado para remo√ß√£o.`); return null; }

                if (value < node.value) {
                    node.left = this._deleteNodeRecursive(node.left, value);
                } else if (value > node.value) {
                    node.right = this._deleteNodeRecursive(node.right, value);
                } else {
                    if (!node.left || !node.right) {
                        const temp = node.left ? node.left : node.right;
                        if (!temp) {
                            node = null;
                        } else {
                            node = temp;
                        }
                        this.log(`üóëÔ∏è N√≥ com valor ${value} removido (tinha 0 ou 1 filho).`);
                    } else {
                        const temp = this._maxValueNode(node.left);
                        this.log(`üîÑ N√≥ ${value} tem 2 filhos. Substituindo pelo predecessor ${temp.value}.`);
                        node.value = temp.value;
                        node.left = this._deleteNodeRecursive(node.left, temp.value);
                    }
                }

                if (!node) return null;
                this.updateHeight(node);

                if (this.autoBalanceEnabled) {
                    const balance = this.getBalanceFactor(node);
                    if (balance > 1 && this.getBalanceFactor(node.left) >= 0) {
                         this.log(`‚öôÔ∏è AUTO-BALANCE (DEL): Rota√ß√£o Simples √† Direita no n√≥ ${node.value} (Caso LL)`);
                        return this.rightRotate(node);
                    }
                    if (balance < -1 && this.getBalanceFactor(node.right) <= 0) {
                         this.log(`‚öôÔ∏è AUTO-BALANCE (DEL): Rota√ß√£o Simples √† Esquerda no n√≥ ${node.value} (Caso RR)`);
                        return this.leftRotate(node);
                    }
                    if (balance > 1 && this.getBalanceFactor(node.left) < 0) {
                        this.log(`‚öôÔ∏è AUTO-BALANCE (DEL): Rota√ß√£o Dupla Esq-Dir no n√≥ ${node.value} (Caso LR)`);
                        node.left = this.leftRotate(node.left);
                        return this.rightRotate(node);
                    }
                    if (balance < -1 && this.getBalanceFactor(node.right) > 0) {
                        this.log(`‚öôÔ∏è AUTO-BALANCE (DEL): Rota√ß√£o Dupla Dir-Esq no n√≥ ${node.value} (Caso RL)`);
                        node.right = this.rightRotate(node.right);
                        return this.leftRotate(node);
                    }
                }
                return node;
            }

            updateAllHeights(node) {
                if (!node) return -1;
                const leftHeight = this.updateAllHeights(node.left);
                const rightHeight = this.updateAllHeights(node.right);
                node.height = 1 + Math.max(leftHeight, rightHeight);
                return node.height;
            }

            findUnbalancedNodeInfoRecursive(node, parent, isLeftChildOfParent) {
                if (!node) return null;
                let unbalancedInfo = this.findUnbalancedNodeInfoRecursive(node.left, node, true);
                if (unbalancedInfo) return unbalancedInfo;
                unbalancedInfo = this.findUnbalancedNodeInfoRecursive(node.right, node, false);
                if (unbalancedInfo) return unbalancedInfo;

                this.updateHeight(node);
                const balance = this.getBalanceFactor(node);

                if (balance > 1 || balance < -1) {
                    let expectedRotation = '';
                    const relevantChild = balance > 1 ? node.left : node.right;
                    const childBalanceFactor = this.getBalanceFactor(relevantChild);

                    if (balance > 1) {
                        if (childBalanceFactor >= 0) expectedRotation = 'SRR';
                        else expectedRotation = 'DLR';
                    } else {
                        if (childBalanceFactor <= 0) expectedRotation = 'SLR';
                        else expectedRotation = 'DRL';
                    }
                    return { nodeToBalance: node, parentNode: parent, isLeftChild: isLeftChildOfParent, expectedRotation, balanceFactor: balance, childBalanceFactor };
                }
                return null;
            }

            checkAndInitiateManualBalance() {
                if (this.autoBalanceEnabled) {
                    this.log("‚ÑπÔ∏è Modo Autom√°tico est√° ativo. Desative para usar balanceamento manual.");
                    this.updateAllHeights(this.root);
                    this.visualize();
                    const stillUnbalanced = this.findUnbalancedNodeInfoRecursive(this.root, null, false);
                    if(stillUnbalanced === null){
                        this.log("üå≥ √Årvore est√° balanceada (Modo Autom√°tico).");
                    } else {
                         this.log(`‚ö†Ô∏è √Årvore N√ÉO est√° balanceada (N√≥: ${stillUnbalanced.nodeToBalance.value}, FB: ${stillUnbalanced.balanceFactor}). O modo autom√°tico pode ter parado ou requer m√∫ltiplas passagens n√£o implementadas para desbalanceamentos complexos em cascata.`);
                    }
                    return;
                }
                if (this.manualBalancingInfo.isActive) {
                    this.log("‚ö†Ô∏è Balanceamento manual j√° est√° ativo. Resolva-o primeiro.");
                    return;
                }
                const bstBox = document.getElementById('bst-explanation-box');
                if(bstBox) bstBox.style.display = 'none';
                this.updateAllHeights(this.root);
                this.visualize();

                const unbalanced = this.findUnbalancedNodeInfoRecursive(this.root, null, false);
                if (unbalanced) {
                    this.manualBalancingInfo = { ...unbalanced, isActive: true };
                    this.log(`‚ö†Ô∏è DESBALANCEAMENTO DETECTADO! N√≥ ${unbalanced.nodeToBalance.value} (FB: ${unbalanced.balanceFactor}). Filho relevante (FB: ${unbalanced.childBalanceFactor}). Escolha a rota√ß√£o apropriada.`);
                    this.updateUIManualMode(unbalanced.nodeToBalance.value, unbalanced.balanceFactor, unbalanced.childBalanceFactor);
                } else {
                    this.log("üå≥ √Årvore est√° balanceada (ou vazia). Nenhum balanceamento manual necess√°rio.");
                    this.updateUINormalMode();
                }
            }

            attemptManualRotation(chosenRotationType) {
                 if (!this.manualBalancingInfo.isActive) return;
                const { nodeToBalance, parentNode, isLeftChild, expectedRotation } = this.manualBalancingInfo;
                let rotatedSubtreeRoot = nodeToBalance;

                if (chosenRotationType === expectedRotation) {
                    this.log(`‚úÖ Rota√ß√£o ${chosenRotationType} ESCOLHIDA CORRETAMENTE para o n√≥ ${nodeToBalance.value}. Aplicando...`);
                    switch (expectedRotation) {
                        case 'SRR':
                            this.log(`üîÑ Aplicando Rota√ß√£o Simples √† Direita no n√≥ ${nodeToBalance.value}`);
                            rotatedSubtreeRoot = this.rightRotate(nodeToBalance);
                            break;
                        case 'SLR':
                            this.log(`üîÑ Aplicando Rota√ß√£o Simples √† Esquerda no n√≥ ${nodeToBalance.value}`);
                            rotatedSubtreeRoot = this.leftRotate(nodeToBalance);
                            break;
                        case 'DLR':
                            this.log(`üîÑ Aplicando Rota√ß√£o Dupla Esq-Dir: 1¬∫ Esq. no filho ${nodeToBalance.left ? nodeToBalance.left.value : 'N/A'}, 2¬∫ Dir. no pai ${nodeToBalance.value}`);
                            if(nodeToBalance.left) nodeToBalance.left = this.leftRotate(nodeToBalance.left);
                            else this.log("‚ö†Ô∏è Erro DLR: Filho esquerdo n√£o existe para rota√ß√£o interna.");
                            rotatedSubtreeRoot = this.rightRotate(nodeToBalance);
                            break;
                        case 'DRL':
                            this.log(`üîÑ Aplicando Rota√ß√£o Dupla Dir-Esq: 1¬∫ Dir. no filho ${nodeToBalance.right ? nodeToBalance.right.value : 'N/A'}, 2¬∫ Esq. no pai ${nodeToBalance.value}`);
                            if(nodeToBalance.right) nodeToBalance.right = this.rightRotate(nodeToBalance.right);
                            else this.log("‚ö†Ô∏è Erro DRL: Filho direito n√£o existe para rota√ß√£o interna.");
                            rotatedSubtreeRoot = this.leftRotate(nodeToBalance);
                            break;
                    }
                    if (parentNode) {
                        if (isLeftChild) parentNode.left = rotatedSubtreeRoot;
                        else parentNode.right = rotatedSubtreeRoot;
                    } else { this.root = rotatedSubtreeRoot; }
                    this.finishManualBalance("N√≥ balanceado com sucesso pela sua escolha!");
                } else {
                    this.log(`‚ùå Rota√ß√£o ${chosenRotationType} INCORRETA para o n√≥ ${nodeToBalance.value}. Esperado: ${expectedRotation}. Tente novamente ou use 'App Balanceia'.`);
                    const explBox = document.getElementById('explanation-box');
                    if(explBox) explBox.style.display = 'none';
                    this.visualize();
                    return;
                }
            }

            autoBalanceOneNode() {
                if (!this.manualBalancingInfo.isActive) return;
                this.log("ü§ñ Deixando o app balancear o n√≥ atual...");
                this.attemptManualRotation(this.manualBalancingInfo.expectedRotation);
            }

            finishManualBalance(message) {
                this.manualBalancingInfo.isActive = false;
                this.updateAllHeights(this.root);
                this.visualize();
                this.updateUINormalMode();
                const explBox = document.getElementById('explanation-box');
                if(explBox) explBox.style.display = 'none';
                this.log(message || "‚ÑπÔ∏è Modo de balanceamento manual desativado. Verifique o balanceamento novamente se necess√°rio.");
            }

            getBalancingExplanation() {
                if (!this.manualBalancingInfo.isActive || !this.manualBalancingInfo.nodeToBalance) return "Nenhum desbalanceamento ativo para explicar.";
                const { nodeToBalance, balanceFactor, expectedRotation } = this.manualBalancingInfo;
                let expl = `O n√≥ "${nodeToBalance.value}" est√° desbalanceado com Fator de Balanceamento (FB) = ${balanceFactor}.\n`;
                expl += `Isto indica que sua sub√°rvore ${balanceFactor > 0 ? 'ESQUERDA' : 'DIREITA'} est√° mais pesada/alta.\n\n`;
                const childSide = balanceFactor > 0 ? 'esquerdo' : 'direito';
                const childNode = balanceFactor > 0 ? nodeToBalance.left : nodeToBalance.right;
                const childNodeVal = childNode ? childNode.value : 'N/A (filho n√£o existe)';
                const actualChildBf = childNode ? this.getBalanceFactor(childNode) : 'N/A';
                expl += `Analisando o filho ${childSide} relevante (n√≥ "${childNodeVal}"):\n`;
                expl += `Seu Fator de Balanceamento √© ${actualChildBf}.\n\n`;
                expl += `CONFIGURA√á√ÉO: N√≥ Pai ("${nodeToBalance.value}", FB=${balanceFactor}), Filho ${childSide} ("${childNodeVal}", FB=${actualChildBf})\n`;
                switch (expectedRotation) {
                    case 'SRR':
                        expl += `CASO: Esquerda-Esquerda (Left-Left).\n`;
                        expl += `MOTIVO: O n√≥ est√° pesado √† esquerda (FB=${balanceFactor}) e seu filho esquerdo tamb√©m est√° pesado √† esquerda ou balanceado (FB filho=${actualChildBf}).\n`;
                        expl += `SOLU√á√ÉO: **Rota√ß√£o Simples √† Direita** no n√≥ "${nodeToBalance.value}".\n`;
                        expl += `A Rota√ß√£o Simples √† Direita promove o filho esquerdo ("${childNodeVal}") a se tornar a nova raiz desta sub√°rvore, enquanto o n√≥ original ("${nodeToBalance.value}") se torna seu filho direito, ajustando as alturas.`;
                        break;
                    case 'SLR':
                        expl += `CASO: Direita-Direita (Right-Right).\n`;
                        expl += `MOTIVO: O n√≥ est√° pesado √† direita (FB=${balanceFactor}) e seu filho direito tamb√©m est√° pesado √† direita ou balanceado (FB filho=${actualChildBf}).\n`;
                        expl += `SOLU√á√ÉO: **Rota√ß√£o Simples √† Esquerda** no n√≥ "${nodeToBalance.value}".\n`;
                        expl += `A Rota√ß√£o Simples √† Esquerda promove o filho direito ("${childNodeVal}") a se tornar a nova raiz, e o n√≥ original ("${nodeToBalance.value}") se torna seu filho esquerdo.`;
                        break;
                    case 'DLR':
                        expl += `CASO: Esquerda-Direita (Left-Right).\n`;
                        expl += `MOTIVO: O n√≥ est√° pesado √† esquerda (FB=${balanceFactor}), mas seu filho esquerdo est√° pesado √† direita (FB filho=${actualChildBf}).\n`;
                        expl += `SOLU√á√ÉO: **Rota√ß√£o Dupla Esquerda-Direita**. Consiste em:\n`;
                        expl += `   1. Uma Rota√ß√£o Simples √† Esquerda no filho esquerdo ("${childNodeVal}").\n`;
                        expl += `   2. Em seguida, uma Rota√ß√£o Simples √† Direita no n√≥ original ("${nodeToBalance.value}").\n`;
                        expl += `Isso alinha o "zig-zag" para uma forma Esquerda-Esquerda antes da rota√ß√£o final no pai.`;
                        break;
                    case 'DRL':
                        expl += `CASO: Direita-Esquerda (Right-Left).\n`;
                        expl += `MOTIVO: O n√≥ est√° pesado √† direita (FB=${balanceFactor}), mas seu filho direito est√° pesado √† esquerda (FB filho=${actualChildBf}).\n`;
                        expl += `SOLU√á√ÉO: **Rota√ß√£o Dupla Direita-Esquerda**. Consiste em:\n`;
                        expl += `   1. Uma Rota√ß√£o Simples √† Direita no filho direito ("${childNodeVal}").\n`;
                        expl += `   2. Em seguida, uma Rota√ß√£o Simples √† Esquerda no n√≥ original ("${nodeToBalance.value}").\n`;
                        expl += `Isso alinha o "zig-zag" para uma forma Direita-Direita antes da rota√ß√£o final no pai.`;
                        break;
                    default: expl += "N√£o foi poss√≠vel determinar a explica√ß√£o para esta configura√ß√£o.";
                }
                return expl;
            }

            generateAndDisplayWikiRotationExample(rotationType) {
                let exampleContent = `<strong>Exemplo Num√©rico para ${rotationType}:</strong>\n\n`;
                let P_val, FE_val, FD_val, N_val;
                let P_fb_antes, FE_fb_antes, FD_fb_antes;
                let P_fb_depois, FE_fb_depois, FD_fb_depois, N_fb_depois;

                const formatTreeExample = (rootVal, rootFb, leftChildStr, rightChildStr) => {
                    let treeStr = `      ${rootVal}(FB:${rootFb})\n`;
                    if (leftChildStr && rightChildStr) {
                        treeStr += `     /   \\\n`;
                        treeStr += `  ${leftChildStr}   ${rightChildStr}\n`;
                    } else if (leftChildStr) {
                        treeStr += `     /\n`;
                        treeStr += `  ${leftChildStr}\n`;
                    } else if (rightChildStr) {
                        treeStr += `         \\\n`;
                        treeStr += `          ${rightChildStr}\n`;
                    }
                    return treeStr;
                };

                const leafStr = (val, fb = "0") => `${val}(FB:${fb})`;

                switch (rotationType) {
                    case 'SRR':
                        P_val = 30; FE_val = 20; N_val = 10;
                        P_fb_antes = "+2"; FE_fb_antes = "+1";
                        exampleContent += "Situa√ß√£o Inicial (Antes da SRR):\n";
                        exampleContent += formatTreeExample(P_val, P_fb_antes, leafStr(FE_val, FE_fb_antes) + `\n / \n`+leafStr(N_val), null);
                        exampleContent += `\nO N√≥ ${P_val} est√° desbalanceado (FB=${P_fb_antes}) e seu filho esquerdo ${FE_val} tem FB=${FE_fb_antes} (caso LL).\n\n`;

                        P_fb_depois = "0"; FE_fb_depois = "0";
                        exampleContent += "Resultado (Ap√≥s SRR):\n";
                        exampleContent += formatTreeExample(FE_val, FE_fb_depois, leafStr(N_val), leafStr(P_val, P_fb_depois));
                        break;

                    case 'SLR':
                        P_val = 10; FD_val = 20; N_val = 30;
                        P_fb_antes = "-2"; FD_fb_antes = "-1";
                        exampleContent += "Situa√ß√£o Inicial (Antes da SLR):\n";
                        exampleContent += formatTreeExample(P_val, P_fb_antes, null, leafStr(FD_val, FD_fb_antes) + `\n     \\ \n      `+leafStr(N_val));
                        exampleContent += `\nO N√≥ ${P_val} est√° desbalanceado (FB=${P_fb_antes}) e seu filho direito ${FD_val} tem FB=${FD_fb_antes} (caso RR).\n\n`;

                        P_fb_depois = "0"; FD_fb_depois = "0";
                        exampleContent += "Resultado (Ap√≥s SLR):\n";
                        exampleContent += formatTreeExample(FD_val, FD_fb_depois, leafStr(P_val, P_fb_depois), leafStr(N_val));
                        break;

                    case 'DLR':
                        P_val = 30; FE_val = 10; N_val = 20;
                        P_fb_antes = "+2"; FE_fb_antes = "-1";
                        exampleContent += "Situa√ß√£o Inicial (Antes da DLR):\n";
                        exampleContent += formatTreeExample(P_val, P_fb_antes, leafStr(FE_val, FE_fb_antes) + `\n    \\ \n     `+leafStr(N_val), null);
                        exampleContent += `\nO N√≥ ${P_val} (FB=${P_fb_antes}) est√° pesado √† esquerda, e seu filho esquerdo ${FE_val} (FB=${FE_fb_antes}) est√° pesado √† direita (caso LR).\n`;
                        exampleContent += "Passo 1: Rota√ß√£o Simples √† Esquerda no filho esquerdo (" + FE_val + ").\n";
                        exampleContent += "Estado Intermedi√°rio (Ap√≥s SLR em FE):\n";
                        exampleContent += formatTreeExample(P_val, "+2", leafStr(N_val,"0")+`\n / \n`+leafStr(FE_val,"0"), null);
                        exampleContent += "\nPasso 2: Rota√ß√£o Simples √† Direita no n√≥ original (" + P_val + ").\n\n";

                        P_fb_depois = "0"; FE_fb_depois = "0"; N_fb_depois = "0";
                        exampleContent += "Resultado (Ap√≥s DLR completa):\n";
                        exampleContent += formatTreeExample(N_val, N_fb_depois, leafStr(FE_val, FE_fb_depois), leafStr(P_val, P_fb_depois));
                        break;

                    case 'DRL':
                        P_val = 10; FD_val = 30; N_val = 20;
                        P_fb_antes = "-2"; FD_fb_antes = "+1";
                        exampleContent += "Situa√ß√£o Inicial (Antes da DRL):\n";
                        exampleContent += formatTreeExample(P_val, P_fb_antes, null, leafStr(FD_val, FD_fb_antes) + `\n   / \n`+leafStr(N_val));
                        exampleContent += `\nO N√≥ ${P_val} (FB=${P_fb_antes}) est√° pesado √† direita, e seu filho direito ${FD_val} (FB=${FD_fb_antes}) est√° pesado √† esquerda (caso RL).\n`;
                        exampleContent += "Passo 1: Rota√ß√£o Simples √† Direita no filho direito (" + FD_val + ").\n";
                        exampleContent += "Estado Intermedi√°rio (Ap√≥s SRR em FD):\n";
                        exampleContent += formatTreeExample(P_val, "-2", null, leafStr(N_val,"0")+`\n    \\ \n     `+leafStr(FD_val,"0"));
                        exampleContent += "\nPasso 2: Rota√ß√£o Simples √† Esquerda no n√≥ original (" + P_val + ").\n\n";

                        P_fb_depois = "0"; FD_fb_depois = "0"; N_fb_depois = "0";
                        exampleContent += "Resultado (Ap√≥s DRL completa):\n";
                        exampleContent += formatTreeExample(N_val, N_fb_depois, leafStr(P_val,P_fb_depois), leafStr(FD_val,FD_fb_depois));
                        break;
                    default: exampleContent += "Tipo de rota√ß√£o desconhecido para exemplo.";
                }

                const displayDiv = document.getElementById(`wiki-${rotationType.toLowerCase()}-example`);
                if(displayDiv) {
                    displayDiv.innerHTML = `<pre class="text-xs bg-slate-100 p-3 rounded overflow-x-auto shadow-inner">${exampleContent}</pre>`;
                }
            }

            generateUnbalancedScenario(type) {
                this.root = null;
                this.log("üßπ √Årvore limpa. Gerando novo cen√°rio de desbalanceamento...");
                this.autoBalanceEnabled = false;
                const toggle = document.getElementById('auto-balance-toggle');
                if(toggle) toggle.checked = false;
                const modeText = document.getElementById('mode-status-text');
                if(modeText) modeText.textContent = "Modo: Balanceamento Manual";
                const checkBtn = document.getElementById('check-balance-btn');
                if(checkBtn) checkBtn.disabled = false;

                let nodesToInsert = [];
                let scenarioName = "";
                let base = Math.floor(Math.random() * 50) + 10;
                let distractor1 = base - 15 - Math.floor(Math.random() * 5);
                let distractor2 = base + 35 + Math.floor(Math.random() * 5);
                let addDistractors = Math.random() > 0.3;

                let scenarioTypeToGenerate = type;
                if (type === 'RANDOM') { // Se o tipo for 'RANDOM', escolhe um dos quatro
                    const types = ['LL', 'RR', 'LR', 'RL'];
                    scenarioTypeToGenerate = types[Math.floor(Math.random() * types.length)];
                }


                switch(scenarioTypeToGenerate) {
                    case 'LL':
                        nodesToInsert = [base + 20, base + 10, base];
                        scenarioName = `LL (para Rota√ß√£o Simples √† Direita) com base ${base+20}`;
                        if(addDistractors) nodesToInsert = [distractor2, distractor1, ...nodesToInsert];
                        break;
                    case 'RR':
                        nodesToInsert = [base, base + 10, base + 20];
                        scenarioName = `RR (para Rota√ß√£o Simples √† Esquerda) com base ${base}`;
                        if(addDistractors) nodesToInsert = [distractor1, distractor2, ...nodesToInsert];
                        break;
                    case 'LR':
                        nodesToInsert = [base + 20, base, base + 10];
                        scenarioName = `LR (para Rota√ß√£o Dupla Esquerda-Direita) com base ${base+20}`;
                        if(addDistractors) nodesToInsert = [distractor2, distractor1, ...nodesToInsert];
                        break;
                    case 'RL':
                        nodesToInsert = [base, base + 20, base + 10];
                        scenarioName = `RL (para Rota√ß√£o Dupla Direita-Esquerda) com base ${base}`;
                        if(addDistractors) nodesToInsert = [distractor1, distractor2, ...nodesToInsert];
                        break;
                }

                this.log(`üìã Gerando cen√°rio: ${scenarioName}`);
                nodesToInsert.forEach(val => {
                    this.root = this._insertNodeRecursiveNoAutoBalance(this.root, val);
                });

                const bstBox = document.getElementById('bst-explanation-box');
                if(bstBox) bstBox.style.display = 'none';

                this.updateAllHeights(this.root);
                this.visualize();
                this.log("üéØ Cen√°rio gerado. Agora clique em 'üõ†Ô∏è Verificar Balanceamento' para iniciar a corre√ß√£o manual.");
                this.checkAndInitiateManualBalance();
            }

            _insertNodeRecursiveNoAutoBalance(node, value) {
                if (!node) {
                    return new Node(value);
                }
                if (value < node.value) {
                    node.left = this._insertNodeRecursiveNoAutoBalance(node.left, value);
                } else if (value > node.value) {
                    node.right = this._insertNodeRecursiveNoAutoBalance(node.right, value);
                }
                this.updateHeight(node);
                return node;
            }


            updateUIManualMode(nodeVal, nodeBf, childBf) {
                const manualControls = document.getElementById('manual-rotation-controls');
                if (manualControls) manualControls.style.display = 'block';

                ['insert-btn', 'remove-btn', 'node-value', 'check-balance-btn'].forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) btn.disabled = true;
                });

                const nodeValueInfo = document.getElementById('manual-node-value-info');
                const nodeBfInfo = document.getElementById('manual-node-bf-info');
                const childBfInfo = document.getElementById('manual-node-child-bf-info');
                if (nodeValueInfo) nodeValueInfo.textContent = nodeVal;
                if (nodeBfInfo) nodeBfInfo.textContent = nodeBf;
                if (childBfInfo) childBfInfo.textContent = childBf;

                const explanationBox = document.getElementById('explanation-box');
                if (explanationBox) explanationBox.style.display = 'none';

                this.visualize();
                if (this.manualBalancingInfo.nodeToBalance && this.manualBalancingInfo.nodeToBalance.element) {
                     this.manualBalancingInfo.nodeToBalance.element.classList.add('highlight-unbalanced');
                }
            }

            updateUINormalMode() {
                const manualControls = document.getElementById('manual-rotation-controls');
                if (manualControls) manualControls.style.display = 'none';

                ['insert-btn', 'remove-btn', 'node-value'].forEach(id => {
                     const elem = document.getElementById(id);
                     if (elem) elem.disabled = false;
                });
                const autoToggle = document.getElementById('auto-balance-toggle');
                const checkBtn = document.getElementById('check-balance-btn');
                if (checkBtn && autoToggle) {
                    checkBtn.disabled = autoToggle.checked;
                }

                const highlighted = document.querySelector('.node.highlight-unbalanced');
                if (highlighted) highlighted.classList.remove('highlight-unbalanced');
                this.visualize();
            }

            visualize() {
                const container = document.getElementById('tree-container');
                const svg = document.getElementById('tree-svg');
                if (!container || !svg) return;

                const oldNodes = container.querySelectorAll('.node');
                oldNodes.forEach(n => n.remove());
                svg.innerHTML = '';
                if (!this.root) { return; }

                const nodeSize = 50; const levelHeight = 100;
                let dynamicHorizontalSpread = container.offsetWidth / 3;
                if (this.root && (this.root.left || this.root.right)) {
                    dynamicHorizontalSpread = Math.max(container.offsetWidth / 2.5, 200);
                } else if (this.root) {
                     dynamicHorizontalSpread = 100;
                }

                const assignCoordinates = (node, x, y, horizontalSpread, depth) => {
                    if (!node) return;
                    node.x = x; node.y = y;
                    const nodeDiv = document.createElement('div');
                    nodeDiv.classList.add('node');
                    if (this.manualBalancingInfo.isActive && node === this.manualBalancingInfo.nodeToBalance) {
                        nodeDiv.classList.add('highlight-unbalanced');
                    }
                    nodeDiv.style.left = `${x - nodeSize / 2}px`;
                    nodeDiv.style.top = `${y - nodeSize / 2}px`;

                    const valueSpan = document.createElement('span');
                    valueSpan.classList.add('node-value'); valueSpan.textContent = node.value;
                    nodeDiv.appendChild(valueSpan);
                    const heightSpan = document.createElement('span');
                    heightSpan.classList.add('node-height'); heightSpan.textContent = `H:${node.height}`;
                    nodeDiv.appendChild(heightSpan);
                    const bfSpan = document.createElement('span');
                    bfSpan.classList.add('node-bf'); bfSpan.textContent = `BF:${this.getBalanceFactor(node)}`;
                    nodeDiv.appendChild(bfSpan);
                    node.element = nodeDiv; container.appendChild(nodeDiv);
                    const nextHorizontalSpread = Math.max(horizontalSpread / 1.85, nodeSize * 0.9);
                    if (node.left) {
                        const childX = x - nextHorizontalSpread; const childY = y + levelHeight;
                        assignCoordinates(node.left, childX, childY, nextHorizontalSpread, depth + 1);
                        this.drawLine(svg, x, y, childX, childY);
                    }
                    if (node.right) {
                        const childX = x + nextHorizontalSpread; const childY = y + levelHeight;
                        assignCoordinates(node.right, childX, childY, nextHorizontalSpread, depth + 1);
                        this.drawLine(svg, x, y, childX, childY);
                    }
                };
                assignCoordinates(this.root, container.offsetWidth / 2, nodeSize + 10, dynamicHorizontalSpread, 0);
            }

            drawLine(svg, x1, y1, x2, y2) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                line.classList.add('line'); svg.appendChild(line);
            }
        }

        let avlTreeApp;

        document.addEventListener('DOMContentLoaded', () => {
            avlTreeApp = new AVLTree();
            const modeStatusText = document.getElementById('mode-status-text');
            const checkBalanceBtn = document.getElementById('check-balance-btn');
            const bstExplanationBox = document.getElementById('bst-explanation-box');
            const autoBalanceToggle = document.getElementById('auto-balance-toggle');

            if(autoBalanceToggle) {
                autoBalanceToggle.addEventListener('change', function() {
                    avlTreeApp.autoBalanceEnabled = this.checked;
                    if (avlTreeApp.autoBalanceEnabled) {
                        if(modeStatusText) modeStatusText.textContent = "Modo: Balanceamento AVL Autom√°tico";
                        if(checkBalanceBtn) checkBalanceBtn.disabled = true;
                        avlTreeApp.log("‚öôÔ∏è Modo de balanceamento autom√°tico ATIVADO.");
                        if (avlTreeApp.manualBalancingInfo.isActive) {
                            avlTreeApp.finishManualBalance("Modo autom√°tico ativado, cancelando balanceamento manual.");
                        }
                        if(bstExplanationBox) bstExplanationBox.style.display = 'none';
                        avlTreeApp.updateAllHeights(avlTreeApp.root);
                        avlTreeApp.visualize();
                    } else {
                        if(modeStatusText) modeStatusText.textContent = "Modo: Balanceamento Manual";
                        if(checkBalanceBtn) checkBalanceBtn.disabled = false;
                        avlTreeApp.log("üñêÔ∏è Modo de balanceamento autom√°tico DESATIVADO. Use 'üõ†Ô∏è Verificar Balanceamento'.");
                        avlTreeApp.visualize();
                    }
                });
            }

            const wikiToggleBtn = document.getElementById('wiki-toggle-btn');
            if(wikiToggleBtn) {
                wikiToggleBtn.addEventListener('click', () => {
                    const wikiDiv = document.getElementById('rotation-wiki');
                    if(wikiDiv) {
                        const isHidden = wikiDiv.style.display === 'none' || wikiDiv.style.display === '';
                        wikiDiv.style.display = isHidden ? 'block' : 'none';
                        avlTreeApp.log(isHidden ? "üìñ Mini-Wiki de rota√ß√µes aberta." : "üìñ Mini-Wiki de rota√ß√µes fechada.");
                        if (isHidden) {
                            document.querySelectorAll('.wiki-example-display').forEach(el => el.innerHTML = '');
                        }
                    }
                });
            }

            document.querySelectorAll('.wiki-example-generator').forEach(button => {
                button.addEventListener('click', (e) => {
                    const rotationType = e.target.dataset.rotationType;
                    if (avlTreeApp && typeof avlTreeApp.generateAndDisplayWikiRotationExample === 'function') {
                        avlTreeApp.generateAndDisplayWikiRotationExample(rotationType);
                    }
                });
            });

            const genRandomScenarioBtn = document.getElementById('gen-random-scenario-btn');
            if(genRandomScenarioBtn) {
                genRandomScenarioBtn.addEventListener('click', () => avlTreeApp.generateUnbalancedScenario('RANDOM'));
            }


            const insertBtn = document.getElementById('insert-btn');
            if(insertBtn) {
                insertBtn.addEventListener('click', () => {
                    const valueInput = document.getElementById('node-value');
                    const value = parseInt(valueInput.value);
                    if (!isNaN(value)) {
                        avlTreeApp.insert(value); valueInput.value = '';
                    } else { avlTreeApp.log("‚ö†Ô∏è Por favor, insira um valor num√©rico v√°lido."); }
                });
            }

            const removeBtn = document.getElementById('remove-btn');
            if(removeBtn) {
                removeBtn.addEventListener('click', () => {
                    const valueInput = document.getElementById('node-value');
                    const value = parseInt(valueInput.value);
                    if (!isNaN(value)) {
                        avlTreeApp.delete(value); valueInput.value = '';
                    } else { avlTreeApp.log("‚ö†Ô∏è Por favor, insira um valor num√©rico v√°lido para remover."); }
                });
            }

            if(checkBalanceBtn) {
                checkBalanceBtn.addEventListener('click', () => {
                    avlTreeApp.checkAndInitiateManualBalance();
                });
            }

            document.querySelectorAll('.manual-rot-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    avlTreeApp.attemptManualRotation(e.target.dataset.rotation);
                });
            });

            const autoBalanceOneBtn = document.getElementById('auto-balance-one-btn');
            if(autoBalanceOneBtn) {
                autoBalanceOneBtn.addEventListener('click', () => {
                    avlTreeApp.autoBalanceOneNode();
                });
            }

            const showExplanationBtn = document.getElementById('show-explanation-btn');
            if(showExplanationBtn) {
                showExplanationBtn.addEventListener('click', () => {
                    if (avlTreeApp.manualBalancingInfo.isActive) {
                        const explanationText = avlTreeApp.getBalancingExplanation();
                        const explanationBox = document.getElementById('explanation-box');
                        if(explanationBox) {
                            explanationBox.textContent = explanationText;
                            explanationBox.style.display = 'block';
                        }
                        avlTreeApp.log("üí° Explica√ß√£o da solu√ß√£o AVL exibida.");
                    } else {
                        avlTreeApp.log("‚ÑπÔ∏è Ative o modo de balanceamento manual primeiro para ver uma explica√ß√£o AVL.");
                        const explanationBox = document.getElementById('explanation-box');
                        if(explanationBox) explanationBox.style.display = 'none';
                    }
                });
            }

            avlTreeApp.visualize();
            window.addEventListener('resize', () => {
                if(avlTreeApp) avlTreeApp.visualize();
            });
        });
    </script>
</body>
</html>
