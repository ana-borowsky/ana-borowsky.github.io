<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guia de Estudos de Grafos</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        html {
            scroll-behavior: smooth;
            overflow-y: scroll;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Adicionado para evitar flash de tela clara */
        }
        .node, .edge, .edge-label {
            transition: all 0.5s ease-in-out;
            user-select: none;
        }
        .feedback-card, #quiz-container {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        /* Estilos para desabilitar inputs */
        .controls-disabled fieldset {
            opacity: 0.5;
            pointer-events: none;
        }
        .mode-btn.active {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
        }
        /* Estilos das abas */
        .tab-btn {
            border-bottom: 2px solid transparent;
        }
        .tab-btn.active {
            border-color: #4f46e5; /* indigo-600 */
            color: #4f46e5;
        }
        /* Estilos para o conteúdo da teoria */
        #theory-content h2, #quiz-content h2 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-top: 2rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #374151; /* slate-700 */
            padding-bottom: 0.5rem;
            color: #f3f4f6; /* gray-100 */
        }
        #theory-content h3 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: #d1d5db; /* gray-300 */
        }
        #theory-content p, #theory-content ul {
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 1rem;
            color: #9ca3af; /* gray-400 */
        }
        #theory-content ul {
            list-style-type: disc;
            padding-left: 1.5rem;
        }
        #theory-content code {
            background-color: #1f2937; /* gray-800 */
            color: #d1d5db; /* gray-300 */
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            font-family: monospace;
        }
        #theory-content strong {
            font-weight: 600;
            color: #d1d5db; /* gray-300 */
        }
        .quiz-option {
            display: block;
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #4b5563; /* gray-600 */
            border-radius: 0.5rem;
            text-align: left;
            transition: all 0.2s;
            cursor: pointer;
            background-color: #374155; /* slate-700 */
            color: #d1d5db; /* gray-300 */
        }
        .quiz-option:hover:not(:disabled) {
            border-color: #4f46e5;
            background-color: #4b5563; /* slate-600 */
        }
        .quiz-option.correct {
            background-color: #14532d; /* green-900 */
            border-color: #22c55e;
            color: #bbf7d0; /* green-200 */
        }
        .quiz-option.incorrect {
            background-color: #7f1d1d; /* red-900 */
            border-color: #ef4444;
            color: #fecaca; /* red-200 */
        }
        /* Estilos para o grafo */
        .node circle {
            stroke-width: 2px;
            fill: #0f172a; /* slate-900 */
            stroke: #22d3ee; /* cyan-400 */
        }
        .node text {
            font-size: 12px;
            font-weight: bold;
            fill: #f1f5f9; /* slate-100 */
            pointer-events: none;
        }
        .node.dragging circle {
            fill: #7c2d12; /* orange-900 */
            stroke: #f97316; /* orange-500 */
        }
        .node.visited circle {
             fill: #14532d; /* green-900 */
            stroke: #4ade80; /* green-400 */
        }
        .node.current circle {
            fill: #7f1d1d; /* red-900 */
            stroke: #f87171; /* red-400 */
            stroke-width: 3px;
        }
        .node.path circle {
            fill: #4c1d95; /* violet-900 */
            stroke: #a78bfa; /* violet-400 */
        }

        .edge {
            stroke: #475569; /* slate-600 */
            stroke-width: 2px;
        }
        .edge.highlighted {
            stroke: #fb923c; /* orange-400 */
            stroke-width: 3px;
        }
        .edge.path {
             stroke: #8b5cf6; /* violet-500 */
            stroke-width: 4px;
        }
        .edge-label {
            font-size: 10px;
            fill: #94a3b8; /* slate-400 */
            font-weight: 500;
            text-anchor: middle;
        }
    </style>
</head>
<body class="bg-gray-900 text-slate-200 flex flex-col items-center min-h-screen p-4">

    <div class="w-full max-w-7xl mx-auto flex flex-col lg:flex-row justify-center gap-8 mt-4">

        <!-- Sidebar Wrapper -->
        <div id="sidebar-wrapper" class="w-full lg:w-64 flex-shrink-0 self-start">
            <aside class="lg:sticky lg:top-4">
                <div class="bg-slate-900/50 border border-slate-700 p-6 rounded-lg">
                    <h3 class="text-xl font-bold text-slate-100 mb-4 border-b border-slate-600 pb-2">Índice</h3>
                    <ul class="space-y-2 list-none p-0">
                        <li><a href="#o-que-sao-grafos" class="text-indigo-400 hover:text-indigo-300 hover:underline">O que são Grafos?</a>
                            <ul class="pl-4 mt-2 space-y-1">
                                <li><a href="#tipos-de-grafos" class="text-slate-400 hover:text-slate-200 hover:underline">Tipos de Grafos</a></li>
                            </ul>
                        </li>
                        <li><a href="#representacoes" class="text-indigo-400 hover:text-indigo-300 hover:underline">Representações</a>
                             <ul class="pl-4 mt-2 space-y-1">
                                <li><a href="#matriz-adjacencia" class="text-slate-400 hover:text-slate-200 hover:underline">Matriz de Adjacência</a></li>
                                <li><a href="#representacao-com-peso" class="text-slate-400 hover:text-slate-200 hover:underline">Com Peso e Informação</a></li>
                                <li><a href="#fechamento-transitivo" class="text-slate-400 hover:text-slate-200 hover:underline">Fechamento Transitivo</a></li>
                            </ul>
                        </li>
                        <li><a href="#algoritmos-fundamentais" class="text-indigo-400 hover:text-indigo-300 hover:underline">Algoritmos Fundamentais</a>
                            <ul class="pl-4 mt-2 space-y-1">
                                <li><a href="#warshall" class="text-slate-400 hover:text-slate-200 hover:underline">Algoritmo de Warshall</a></li>
                                <li><a href="#dijkstra" class="text-slate-400 hover:text-slate-200 hover:underline">Algoritmo de Dijkstra</a></li>
                            </ul>
                        </li>
                         <li><a href="#travessia" class="text-indigo-400 hover:text-indigo-300 hover:underline">Travessia em Grafos</a>
                            <ul class="pl-4 mt-2 space-y-1">
                                <li><a href="#dfs" class="text-slate-400 hover:text-slate-200 hover:underline">Busca em Profundidade (DFS)</a></li>
                                <li><a href="#bfs" class="text-slate-400 hover:text-slate-200 hover:underline">Busca em Largura (BFS)</a></li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </aside>
        </div>

        <main class="w-full flex-grow lg:max-w-[62rem] bg-slate-800 rounded-2xl shadow-lg p-6 md:p-8">
            <header class="mb-6 text-center">
                <h1 class="text-2xl md:text-3xl font-bold text-slate-100">Guia de Estudos de Grafos</h1>
                <p class="text-slate-400 mt-2">Alterne entre 'Teoria', 'Prática' e 'Quiz' para aprofundar seus conhecimentos.</p>
            </header>

            <!-- Abas de Navegação -->
            <div class="border-b border-slate-700 mb-6">
                <nav class="flex -mb-px space-x-6" aria-label="Tabs">
                    <button id="tab-theory" class="tab-btn active whitespace-nowrap py-3 px-1 text-sm font-semibold transition-colors">Teoria</button>
                    <button id="tab-practice" class="tab-btn whitespace-nowrap py-3 px-1 text-sm font-semibold text-slate-400 hover:text-slate-200 transition-colors">Prática</button>
                    <button id="tab-quiz" class="tab-btn whitespace-nowrap py-3 px-1 text-sm font-semibold text-slate-400 hover:text-slate-200 transition-colors">Quiz</button>
                </nav>
            </div>

            <!-- Conteúdo da Aba de Teoria -->
            <div id="theory-content">
                <div class="text-left max-w-4xl mx-auto">
                    <h2 id="o-que-sao-grafos">O que são Grafos?</h2>
                    <p>
                        Um grafo consiste de um conjunto de nós e um conjunto de arcos. Cada arco em um grafo é especificado como um par de nós. A Figura 1 ilustra um grafo. O conjunto de
                        nós é {A,B,C,D,E,F,G,H} e o conjunto de arcos é {(A,B), (A,D), (A,C), (C,D), (C,F), (E,G), (A,A)}.
                    </p>
                    <img src="src/assets/images/imagem1.png" class="w-1/3 block mx-auto my-4 rounded-md border border-slate-600">
                    <p>
                        Ele consiste em duas partes principais:
                    </p>
                    <ul>
                        <li><strong>Vértices (ou Nós):</strong> Representam os objetos ou entidades. Pense neles como cidades em um mapa, pessoas em uma rede social ou páginas na web.</li>
                        <li><strong>Arestas (ou Arcos):</strong> Representam as conexões ou relações entre os vértices. Uma aresta conecta um par de vértices, como uma estrada entre duas cidades ou um link entre duas páginas.</li>
                    </ul>
                    <p>
                    Um grafo é comumente utilizado para representar <strong>Relações</strong>. Uma relação R sobre um conjunto A de nós é um conjunto de pares ordenados a partir de A. Por exemplo, se A =
                    {3, 5, 6, 8, 10, 17} e o conjunto R = {<3,10>, <5,6>, <5,8>, <6, 17>, <8,17>, <10,17>}
                    é uma relação. A relação R é obtida computando o resto da divisão do valor armazenado no nó pelo valor associado ao arco (Figura 3). Quando um grafo possui arcos com
                    valores associados, o grafo é dito <strong>grafo com peso</strong>, onde o valor associado ao arco é o <strong>peso do arco</strong>.
                    Um caminho de tamanho k de um nó a até um no b consiste numa seqüência de k + 1 nós n1, n2, ..., nk+1 tal que n1 = a e nk+1 = b e (ni é adjacente a ni+1) para 1 < i < k. Na
                    Figura 2 existe um caminho de tamanho 2 entre os nós A e D: {A,C,D}.Um caminho de um nó n até ele mesmo é chamado um ciclo. Um grafo que possui ciclos é chamado
                    <strong>cíclico</strong> e um grafo que não possui ciclos é chamado <strong>acíclico</strong>.
                    </p>
                    <h3 id="tipos-de-grafos">Tipos de Grafos</h3>
                    <p>Grafos podem ser classificados de várias maneiras, dependendo de suas propriedades:</p>
                    <ul>
                        <li><strong>Grafo Não-Direcionado:</strong> As arestas não têm uma direção. Se existe uma aresta entre A e B, a conexão é mútua (A está conectado a B e B está conectado a A). Ex: amizades no Facebook.</li>
                        <img src="src/assets/images/imagem1.png" class="w-1/3 block mx-auto my-4 rounded-md border border-slate-600">
                        <li><strong>Grafo Direcionado (Dígrafo):</strong> As arestas têm uma direção, indicadas por setas. Uma aresta de A para B não implica necessariamente uma aresta de B para A. Se um nó representa um par ordenado então o grafo é chamado de direcionado ou
                        dígrafo. A Figura 2 ilustra um dígrafo. O conjunto de arcos da Figura 2 é {<A,B>, <A,C>, <A,D>, <C,D>, <F,C>, <E,G>, <A,A>}. São utilizados “()” para denotar
                        ligações não direcionadas e “<>” para denotar ligações dirigidas. Ex: seguir alguém no Instagram.</li>
                        <img src="src/assets/images/imagem2.png" class="w-1/3 block mx-auto my-4 rounded-md border border-slate-600">
                        <li><strong>Grafo Ponderado:</strong> Cada aresta tem um valor numérico associado, chamado de <strong>peso</strong>. Esse peso pode representar distância, custo, tempo, etc. Pode-se verificar que todas árvore é um grafo, mas o contrário nem sempre é
                        verdadeiro, além disso, um nó pode não possuir nenhum arco ligado a ele. Um nó n é chamado incidente sobre um arco x se n é um dos nós que constituem o par
                        ordenado x (também diz-se que x é incidente sobre n). O grau de um nó é o número de arcos que são incidentes sobre ele. O grau de entrada de um nó n é o número de arcos
                        que chegam em n. O grau de saída de um nó é o número de arcos que partem de n. Um nó n é adjacente a um nó m se há um arco partindo de m para n. Se n é adjacente a m, n
                        é chamado sucessor de m e m o predecessor de n. Ex: um mapa de estradas onde o peso é a distância entre cidades.</li>
                        <img src="src/assets/images/imagem3.png" class="w-1/3 block mx-auto my-4 rounded-md border border-slate-600">
                        <li><strong>Grafo Não-Ponderado:</strong> As arestas não têm pesos. Assume-se que todas as conexões têm o mesmo "custo" (geralmente 1).</li>
                        <li><strong>Grafo simples:</strong> um tipo de grafo que não possui laços (arestas que conectam
                          um vértice a si mesmo) nem arestas múltiplas (mais de uma aresta ligando o
                          mesmo par de vértices).</li>
                        <li><strong>Grafo rotulado:</strong> é um grafo onde vértices ou arestas possuem rótulos
                          associados, que podem ser números, letras ou outros símbolos, para
                          representar informações adicionais ou funções.</li>
                        <li><strong>Grafo conexo/desconexo:</strong> Um grafo é considerado conexo se existe um
                          caminho entre qualquer par de vértices no grafo. Caso contrário, o grafo é
                          chamado de desconexo.</li>
                        <li><strong>Grafo completo:</strong> é um tipo de grafo em que todos os pares de vértices
                            distintos são conectados por uma aresta.</li>
                        <li><strong>Grafo conexo:</strong> um grafo é considerado conexo se existe um caminho entre
                            qualquer par de vértices no grafo. Caso contrário, o grafo é chamado de
                            desconexo.</li>
                        <li><strong>Grafo bipartido completo:</strong> é um tipo especial de grafo bipartido onde cada
                          vértice de um conjunto é conectado a todos os vértices do outro conjunto.</li>
                        <li><strong>Grafo planar:</strong> um grafo que pode ser representado no plano sem que suas
                          arestas se cruzem.</li>
                        <li><strong>Grafo cíclico</strong>Um caminho de um nó n até ele mesmo é chamado um ciclo. Um grafo que possui ciclos é chamado cíclico.
                        <li><strong>Grafo acíclico</strong>um grafo que não possui ciclos.</li>
                    </ul>


                    <h3>Conceitos</h3>
                    <ul>
                      <li>Vértices adjacentes: vértices que estão conectados por uma aresta.</li>
                      <li>Laço: é uma aresta que conecta um vértice a ele mesmo.</li>
                      <li>Arestas paralelas: duas ou mais arestas que conectam o mesmo par de
                          vértices em um grafo.</li>
                      <li>Caminho: um caminho em um grafo é uma sequência finita ou infinita de
                          vértices conectados por uma sequência de arestas que, na maioria das
                          definições, são todos diferentes uns dos outros. O primeiro vértice é chamado
                          de vértice inicial e o último é chamado de vértice final.</li>
                      <li>Comprimento/tamanho do caminho: é o número de arestas que ele contém.</li>
                      <li>Ciclo: um conjunto de vértices conectados em uma sequência fechada.</li>
                      <li>Grafo cíclico/acíclico: possui pelo menos um ciclo, ou seja, um caminho
                          fechado que começa e termina no mesmo vértice, sem passar duas vezes
                          pelo mesmo vértice intermediário. Por outro lado, um grafo acíclico é aquele
                          que não contém nenhum ciclo.</li>
                      <li>Subgrafo: um subgrafo de um grafo G é um grafo cujo conjunto de vértices é
                          um subconjunto do conjunto de vértices G e o conjunto de arestas é um
                          subconjunto do conjunto de arestas de G,[1] ou seja, cuja relação de
                          adjacência é um subconjunto de G restrita a esse subconjunto. Dizemos que
                          um grafo G contém um outro grafo H se algum subgrafo de G é H ou é
                          isomorfo a H.</li>
                      <li>Grau de um vértice: quantidade de arestas ligadas a ele.</li>
                      <li>Grau de entrada de um vértice: é o número de arestas que chegam a ele.</li>
                      <li>Grau de saída de um vértice: número de arestas que partem dele.</li>
                      <li>Vértice isolado: vértice de grau zero.</li>
                      <li>Componente de um grafo: Em um grafo vazio , cada vértice forma um
                        componente com um vértice e zero arestas. De forma mais geral, um
                        componente desse tipo é formado para cada vértice isolado em qualquer
                        grafo.</li>
                    </ul>

                    <h2 id="representacoes">Representações de Grafos</h2>
                    <h3 id="matriz-adjacencia">Matriz de Adjacência</h3>

                    <p>
                        Se um grafo possui o número de nós constante (nós não podem ser criados e removidos), por exemplo MAX e não possui pesos nos arcos ele pode ser representado
                        como uma matriz m booleana quadrada de tamanho MAX. Quando a posição m[i][j] é true então existe um arco que sai de i e chega em j, ou seja, j é adjacente a i. A Figura 4
                        ilustra a representação de um grafo e sua matriz de adjacência correspondente.
                    </p>
                    <img src="src/assets/images/imagem4.png" class="w-3/4 block mx-auto my-4 rounded-md border border-slate-600">
                    <p>
                        A representação de um grafo sem peso, sem informação associada e número constante de nós pode ser obtida simplesmente com a declaração:
                    </p>
                    <img src="src/assets/images/imagem10.png" class="w-1/2 block mx-auto my-4 rounded-md border border-slate-600">
                    <h3 id="representacao-com-peso">Representação de Grafos com Peso e Informação nos Nós</h3>
                    <p>
                        Como comentado anteriormente, um grafo pode necessitar armazenar pesos em seus
                        arcos e informação dentro de cada nó. Desta forma uma possível representação com um
                        número constante (MAX) de nós (nós não podem ser adicionados ou removidos) seria a
                        seguinte:
                    </p>
                    <img src="src/assets/images/imagem5.png" class="w-3/4 block mx-auto my-4 rounded-md border border-slate-600">

                    <h3 id="fechamento-transitivo">Fechamento Transitivo</h3>
                    <p>
                        Nesta seção é assumido que um grafo é descrito por sua matriz de adjacência m e não há
                        informação contida no nó nem nas ligações. Dada a expressão m[i][k] && m[k][j],
                        obtém-se o valor true se e somente se os valores de m[i][k] e m[k][j] são true, logo isso
                        implica que há um caminho de tamanho 2 entre o nó i e o nó j que passa por k. Portanto
                        dada a expressão:
                    </p>
                    <img src="src/assets/images/imagem6.png" class="w-3/4 block mx-auto my-4 rounded-md border border-slate-600"><br>

                    <p>
                        ela será true se que há um caminho de tamanho 2 de i até j passando por 0, ou passando
                        por 1 ou passando por 2 ... ou passando por MAX-1. A matriz m representa todos os
                        caminhos de tamanho 1. A matriz m2 representa a matriz de todos os caminhos de
                        tamanho 2, a matriz m3. A multiplicação de matrizes booleanas é feita de maneira
                        semelhante à multiplicação de matrizes numéricas. Obviamente não será possível fazer
                        a multiplicação nem a soma de elementos da matriz. As únicas modificações necessárias
                        no algoritmo de multiplicação de matrizes são:
                    </p>

                    <ul>
                        <li>substituir somas pelo operador de disjunção “| |”;</li>
                        <li>substituir multiplicações pelo operador de conjunção “&&”.</li>
                    </ul>

                    <p>
                        A Figura 5 ilustra o processo pelo qual se pode encontrar todos os caminhos de tamanho
                        2 dentro de um determinado grafo.
                    </p>

                    <img src="src/assets/images/imagem7.png" class="w-1/2 block mx-auto my-4 rounded-md border border-slate-600"><br>

                    <p>
                        Portanto se for necessário encontrar todos os caminhos de tamanho tam dentro de um
                        grafo, basta encontrar a matriz mtam. Para verificar se há um caminho de tamanho tam
                        entre dois nós i e j, basta verficar se mtam[i][j] = true.
                        A soma (ou disjunção) dentre duas matrizes mi + mj (mi | | mj) retorna, portanto, todos
                        os caminhos de tamanho i ou j dentro do grafo. Pode-se concluir que se é necessário
                        encontrar todos os caminhos no grafo de quaisquer tamanhos, basta realizar o seguinte
                        somatório (disjunção):
                    </p>

                    <img src="src/assets/images/imagem8.png" class="w-1/3 block mx-auto my-4 rounded-md border border-slate-600"><br>
                    <p>
                        o que é equivalente a:
                    </p>
                    <img src="src/assets/images/imagem9.png" class="w-1/3 block mx-auto my-4 rounded-md border border-slate-600"><br>
                    <p>
                        A matriz obtida pelo somatório (disjunção) anterior é chamada de <strong>fechamento
                        transitivo</strong> da matriz m e representa todos os caminhos existentes dentro do grafo
                        independente de tamanho.
                    </p>
                    <h2 id="algoritmos-fundamentais">Algoritmos Fundamentais</h2>
                    <h3 id="warshall">Algoritmo de Warshall</h3>
                    <p>
                        Na aula anterior foi estudado como era possível encontrar o fechamento transitivo de
                        um grafo representado como matriz de adjacência. Tal método consistia em encontrar a
                        matriz mtam utilizando sucessivas operações de soma (disjunção). Existe um algoritmo
                        chamado Algoritmo de Warshall que é capaz de encontrar o fechamento transitivo de
                        um grafo representado como matriz de adjacência.
                        O algoritmo inicia com um índice k que representa as colunas da matriz. Para cada valor
                        de k tenta-se encontrar uma linha i com valor true. Se uma linha i com valor true é
                        encontrada, faz-se uma atualização dessa linha i com a disjunção entre essa linha e a
                        linha que possui o índice k.
                        O algoritmo de Warshall está colocado a seguir.
                    </p>

                    <img src="src/assets/images/imagem11.png" class="block mx-auto my-4 rounded-md border border-slate-600"><br>

                    <h3 id="dijkstra">Algoritmo de Dijkstra</h3>
                    <p>
                        Em um grafo com peso, uma operação muito comum consiste em encontrar o menor
                        caminho entre dois nós. O caminho mais curto entre dois nós s e t é o caminho cuja
                        soma dos arcos é minimizado. Será assumido a existência de uma função peso(i,j) que
                        retorna o peso do arco que sai de i e chega em j. Caso este arco não exista, a função
                        retornará um valor bastante grande chamado infinito que denota a situação de
                        impossibilidade de se alcançar o nó j a partir de i em um único passo.
                    </p>
                    <p>
                        O algoritmo funciona da seguinte forma:
                        distancia[i] armazena o custo do menor caminho do nó s até i. Inicialmente distancia[s]
                        = 0 e distancia[i] = infinito para todo i != s. Um conjunto perm contém todos os nós
                        cuja distância mínima de s é conhecida, ou seja, aqueles nós cujo valor da distância é
                        fixa e não mudará. Se um nó i é um membro de perm, distancia[i] é a distância mínima
                        de s até i. Inicialmente, o único membro de perm é s. Uma vez que t torna-se um
                        membro de perm, sabe-se que distancia[t] é a menor distância de s até t e o algoritmo
                        termina.
                    </p>
                    <p>
                        O algoritmo mantém uma variável chamada corrente, que é o último nó adicionado a
                        perm. Inicialmente corrente = s. Quando um nó corrente é adicionado a perm a
                        distância deve ser recalculada para todos os sucessores de corrente. Para qualquer
                        sucessor i de corrente, se distancia[corrente] + peso(corrente,i) é menor que
                        distancia[i], a distância de s até i passando por corrente é menor que qualquer outra
                        distância de s até i encontrada até esse momento. Portanto, distancia[i] deve ser
                        atualizada com esse menor valor.
                    </p>
                    <p>
                        Uma vez que distancia foi recalculada para todo sucessor de corrente, distancia[j] (para
                        qualquer j) representa o caminho mais curto de s até j que inclui somente membros de
                        perm (exceto o próprio j). Isto significa que para todo k que não pertence a perm, para
                        qual distancia[k] é o menor, não há caminho de s até k cujo tamanho é mais curto que
                        distancia[k]. Desta forma k pode ser adicionado a perm. corrente é então reiniciado com
                        k e o processo é repetido.
                    </p>
                    <p>
                        O método a seguir implementa o algoritmo do menor caminho. O método utiliza um
                        conjunto adicional caminho tal que caminho[i] é o nó que precede o nó i no caminho
                        mais curto encontrado. O procedimento retorna a menor distância entre dois nós s e t e
                        armazena em precede os nós que formam o menor caminho.
                    </p>
                    <img src="src/assets/images/imagem12.png" class="w-1/2 block mx-auto my-4 rounded-md border border-slate-600"><br>
                    <p>
                        A partir do vetor caminho pode-se mostrar o menor caminho encontrado pelo algoritmo
                        com o procedimento imprimeCaminho.
                    </p>
                    <img src="src/assets/images/imagem13.png" class="w-1/2 block mx-auto my-4 rounded-md border border-slate-600"><br>

                    <h4>Exercícios</h4>
                    <p>1. A partir do grafo representado na Figura 1:</p>
                    <img src="src/assets/images/imagem1.png" class="w-1/3 block mx-auto my-4 rounded-md border border-slate-600">
                    <ul>

                        <li>a) encontre sua representação como matriz de adjacência;</li>
                        <li>b) encontre o fechamento transitivo do grafo utilizando multiplicação de matrizes;</li>
                        <li>c) encontre o fechamento transitivo do grafo utilizando o algoritmo de Warshall.</li>
                        <li>2. Ilustre graficamente um dígrafo correspondente a cada uma das seguintes relações
                        sobre inteiros de 1 a 12:</li>
                        <li>a) x está relacionado a y se x – y é divisível por 3;</li>
                        <li>b) x está relacionado a y se (x + 10 * y) < (x * y);</li>
                        <li>c) x está relacionado a y se o resto da divisão de x por y é 2.</li>
                    </ul>

                    <h2 id="travessia">Travessia em Grafos</h2>
                    <p>
                    Muitos problemas com grafos envolvem a travessia e acesso a todos os vértices de um grafo.
                    Durante aulas anteriores já foram estudados métodos de travessia em árvore binária (inordem,
                    pré-ordem e pós-ordem) e lista encadeada (seqüencial). Porém, quando tratamos de travessia em
                    grafos não existe uma ordenação natural entre os vértices, diferentemente de árvores ou listas.
                    Portanto algumas questões tornam a travessia em grafo mais complexa:
                    </p>
                    <ul>
                        <li>Não existe um nó que naturalmente seja o inicial. Em uma lista encadeada sempre inicia-se
                        com o primeiro da lista e árvore sempre com a raiz. Além disso, quando um nó inicial é pré-
                        determinado, nem sempre todos os vértices do grafo poderão ser visitados, pois podem
                        existir vértices que não são alcançáveis a partir do nó inicial. Em lista ou árvore, todos os nós
                        eram visitados, desta forma, um novo nó inicial deve ser determinado para que o grafo seja
                        completamente percorrido;</li>
                        <li>Não há uma ordem natural entre os sucessores de um determinado vértice. Desta forma, a
                        partir de um determinado vértice, não há uma ordem obrigatória na qual os sucessores são
                        visitados;</li>
                        <li>Um determinado vértice pode ter mais de um predecessor, desta forma, se um determinado
                        vértice v possui mais de um predecessor, é possível que v seja visitado antes de algum
                        predecessor.</li>
                    </ul>
                    <p>
                        Existem duas formas tradicionais de travessia em grafos: busca em largura e profundidade. A
                        busca em largura utiliza uma lista para armazenar os vértices visitados. A busca em
                        profundidade utiliza uma pilha que não precisa ser explicitamente implementada quando se
                        utiliza recursão.
                    </p>

                    <h3 id="dfs">Busca em Profundidade (DFS)</h3>
                    <p>
                        Será considerado que a tarefa do procedimento de travessia consiste em a partir de um
                        determinado vértice (neste exemplo “0”) visitar (processar) todos os outros vértices. Considere a
                        Figura 1.
                    </p>
                    <img src="src/assets/images/imagem14.png" class="w-1/3 block mx-auto my-4 rounded-md border border-slate-600">
                    <p>
                        A partir do grafo anterior o primeiro nó a ser processado é o nó
                        inicial 0. O grafo da Figura 1 é ilustrado na Figura 2. A partir
                        do nó inicial há duas alternativas: continuar o processo no nó 1
                        ou no nó 4. Considere que o nó escolhido é o nó 1. O processo
                        é ilustrado na Figura 3.
                        A partir do nó 1 seu único vizinho ainda não visitado é
                        escolhido para que o processo continue. Essa situação é
                        ilustrada na Figura 4.
                    </p>
                    <img src="src/assets/images/imagem15.png" class="block mx-auto my-4 rounded-md border border-slate-600">
                    <p>
                        Seguindo a estratégia de escolher o nó com menor conteúdo (ou menor nó) para prosseguir o
                        processo de travessia, a partir do nó 3 o nó 0 seria o escolhido. Essa é uma situação interessante.
                        Se o nó 0 for o escolhido, o processo de travessia entrará em loop infinito, pois o caminho 0-1-3-
                        0 forma um ciclo, uma vez que a origem e o destino do caminho são os mesmos. Portanto é
                        necessário uma estratégia para evitar tal problema. Geralmente um nó marcado como visitado
                        nunca será escolhido novamente, uma vez que ele já foi processado. Portanto restam os vértices
                        5 e 6 (adjacentes a 3). Considerando que o vértice 5 seja o escolhido, o grafo seria representado
                        mostra a Figura 5.
                    </p>
                    <img src="src/assets/images/imagem16.png" class="block mx-auto my-4 rounded-md border border-slate-600">
                    <p>
                        Como o vértice 5 não possui nós adjacentes, a busca não pode continuar seguindo adiante. Neste
                        caso o processo retorna para o vértice visitado anteriormente (vértice 3) e verifica se existe mais
                        algum nó adjacente que ainda não foi visitado. Neste exemplo o vértice 3 possui o vértice 6
                        adjacente e não visitado, portanto o vértice 6 será o próximo vértice escolhido, como ilustrado na
                        Figura 6. Como o vértice 6 não possui mais vértices adjacentes ainda não visitados, o processo
                        retorna para o vértice 3. Neste ponto, o vértice 3 também não possui nenhum outro nó adjacente
                        ainda não visitado, portanto, o processo retorna para o nó anterior ao 3 (vértice 1) e tenta
                        encontrar outro nó adjacente não visitado. Como o vértice 1 não possui nenhum nó adjacente
                        ainda não visitado, o processo retorna ao vértice 0 que possui o adjacente 4 ainda não visitado.
                        Logo o vértice 4 é escolhido como ilustrado na Figura 7. Como não há mais nenhum vértice
                        adjacente a 0 e ele é o vértice inicial, o processo é encerrado.
                    </p>
                    <img src="src/assets/images/imagem17.png" class="block mx-auto my-4 rounded-md border border-slate-600">
                    <p>
                        É possível perceber que esse processo pode ser implementado de maneira muito simples
                        utilizando um algoritmo recursivo. A pilha de chamadas recursivas é ilustrada na Figura 8.
                    </p>
                    <h3 id="bfs">Busca em Largura (BFS)</h3>
                    <p>1. Se a fila de vértices não está vazia então</p>
                    <ul>
                        <li>1.1. Remover o vértice i que está na fila // note-se que uma fila sempre remove o primeiro elemento</li>
                        <li>1.2. Processar o vértice i</li>
                        <li>1.3. Adicionar os vértices adjacentes a i na fila // um nó só é adicionado se ele já não foi visitado</li>
                        <li>1.4. Executar o procedimento 1 sobre a fila atualizada</li>
                    </ul>
                    <p>
                        É importante ressaltar que na primeira chamada do algoritmo a fila contém um único vértice que
                        é o vértice inicial.
                    </p>
                    <h3>Vantagens e desvantagens de Busca em Profundidade e Largura</h3>
                    <p>
                        As duas metodologias de travessia em grafos possuem vantagens e desvantagens. Ambas podem
                        ser utilizadas para se encontrar um determinado elemento dentro de um grafo. Considere-se, por
                        exemplo as Figuras 15 e 16
                    </p>
                    <p>
                        Os grafos das Figuras 15 e 16 são os mesmos. A partir do vértice 0 tenta-se encontrar o vértice o
                        vértice 6. Pode-se verificar que se a busca em profundidade é utilizada muito mais vértices
                        precisam ser visitados para que a solução seja encontrada. No exemplo, os vértices [0, 1, 2, 3, 4,
                        8, 9, 5, 10, 11, 12, 2 e 6] precisam ser visitados. Por outro lado, com busca em largura muito
                        menos vértices precisam ser visitados [0, 1, 2, 3, 4, 5, 6].
                        Geralmente a busca em largura tende a encontrar a solução de um problema de busca
                        necessitando menos comparações. Além disso a busca em largura trata naturalmente o problema
                        de ciclos em grafos. Porém sua implementação tende a ser mais complexa, pois necessita de uma
                        fila para armazenar os vértices.
                        A busca em profundidade possui uma implementação mais simples, porém necessita de um
                        mecanismo auxiliar para tratamento de ciclos, geralmente implementado marcando os vértices
                        como visitados.
                    </p>
                    <img src="src/assets/images/imagem18.png" class="block mx-auto my-4 rounded-md border border-slate-600">

                    <h3>Exercício</h3>
                    <p>
                        A partir do Grafo a seguir mostrar a seqüência com que os vértices são visitados executando
                        tanto busca em largura quanto busca em profundidade a partir do vértice A:
                    </p>
                    <img src="src/assets/images/imagem19.png" class="w-1/3 block mx-auto my-4 rounded-md border border-slate-600">



                </div>
            </div>

            <!-- Conteúdo da Aba de Prática -->
            <div id="practice-content" class="hidden">
                 <p class="text-slate-400 text-center mb-6 -mt-2">Use o modo 'Sandbox' para construir seu grafo ou visualize 'Algoritmos' em ação.</p>
                <div class="flex flex-col lg:flex-row gap-8">
                    <!-- Coluna de Controles -->
                    <div id="controls-section" class="lg:w-1/4">
                        <fieldset id="controls-fieldset">
                            <!-- Controles do Grafo -->
                            <div id="sandbox-controls">
                                <h2 class="text-xl font-bold text-slate-100 mb-4 text-left">Sandbox</h2>
                                <div class="space-y-4">
                                    <div class="bg-slate-700 p-4 rounded-lg text-left">
                                        <label class="block text-sm font-medium text-slate-300">Nós (Vértices)</label>
                                        <div class="flex items-center gap-2 mt-1">
                                            <button id="add-node-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-4 rounded-md transition-colors">Adicionar Nó</button>
                                            <button id="remove-node-btn" class="w-full bg-red-600 hover:bg-red-700 text-white font-medium py-2 px-4 rounded-md transition-colors">Remover Nó</button>
                                        </div>
                                        <p class="text-xs text-slate-400 mt-1">Clique na tela para adicionar ou no nó para remover.</p>
                                    </div>
                                    <div class="bg-slate-700 p-4 rounded-lg text-left">
                                        <label class="block text-sm font-medium text-slate-300">Arestas</label>
                                        <div class="grid grid-cols-2 gap-2 mt-1">
                                            <input type="number" id="from-node-input" placeholder="De" class="p-2 bg-slate-600 border border-slate-500 text-slate-100 placeholder-slate-400 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                                            <input type="number" id="to-node-input" placeholder="Para" class="p-2 bg-slate-600 border border-slate-500 text-slate-100 placeholder-slate-400 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                                            <input type="number" id="weight-input" placeholder="Peso (opcional)" value="1" class="col-span-2 p-2 bg-slate-600 border border-slate-500 text-slate-100 placeholder-slate-400 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                                        </div>
                                         <div class="flex items-center gap-2 mt-2">
                                            <button id="add-edge-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-4 rounded-md transition-colors">Adicionar</button>
                                            <button id="remove-edge-btn" class="w-full bg-orange-500 hover:bg-orange-600 text-white font-medium py-2 px-4 rounded-md transition-colors">Remover</button>
                                        </div>
                                    </div>
                                    <div class="bg-slate-700 p-4 rounded-lg text-left">
                                        <label class="block text-sm font-medium text-slate-300">Gerar Grafo Aleatório</label>
                                        <div class="grid grid-cols-2 gap-2 mt-1">
                                            <input type="number" id="random-nodes-input" placeholder="Nós" value="5" min="1" class="p-2 bg-slate-600 border border-slate-500 text-slate-100 placeholder-slate-400 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                                            <input type="number" id="random-edges-input" placeholder="Arestas" value="4" min="0" class="p-2 bg-slate-600 border border-slate-500 text-slate-100 placeholder-slate-400 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                                        </div>
                                        <button id="generate-random-graph-btn" class="w-full mt-2 bg-purple-600 hover:bg-purple-700 text-white font-medium py-2 px-4 rounded-md transition-colors">Gerar</button>
                                    </div>
                                    <button id="clear-graph-btn" class="w-full bg-slate-600 hover:bg-slate-500 text-white font-medium py-2 px-4 rounded-md transition-colors">Limpar Tudo</button>
                                </div>
                            </div>

                            <!-- Controles de Algoritmo -->
                            <div id="algorithm-controls" class="mt-6">
                                <h2 class="text-xl font-bold text-slate-100 mb-4 text-left">Algoritmos</h2>
                                 <div class="bg-slate-700 p-4 rounded-lg text-left space-y-3">
                                     <div>
                                        <label for="algorithm-select" class="block text-sm font-medium text-slate-300">Escolha o algoritmo</label>
                                        <select id="algorithm-select" class="w-full mt-1 p-2 bg-slate-600 border border-slate-500 text-slate-100 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                                            <option value="bfs">Busca em Largura (BFS)</option>
                                            <option value="dfs">Busca em Profundidade (DFS)</option>
                                            <option value="dijkstra">Dijkstra (Caminho Mais Curto)</option>
                                        </select>
                                     </div>
                                     <div class="flex items-center gap-2">
                                        <input type="number" id="start-node-input" placeholder="Nó inicial" class="w-full p-2 bg-slate-600 border border-slate-500 text-slate-100 placeholder-slate-400 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                                        <input type="number" id="end-node-input" placeholder="Nó final" class="w-full p-2 bg-slate-600 border border-slate-500 text-slate-100 placeholder-slate-400 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 hidden">
                                     </div>
                                     <button id="run-algorithm-btn" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-medium py-2 px-4 rounded-md transition-colors">Visualizar</button>
                                 </div>
                            </div>
                        </fieldset>
                        <div id="algorithm-info" class="hidden mt-4 p-4 bg-blue-900/50 border border-blue-500/30 rounded-lg text-sm text-blue-200">
                            <h3 id="info-title" class="font-bold mb-2"></h3>
                            <p id="info-description"></p>
                        </div>
                    </div>

                    <!-- Coluna da Visualização -->
                    <div class="lg:w-3/4 flex flex-col">
                        <div id="visualization-container" class="w-full min-h-[400px] lg:min-h-0 flex-grow bg-slate-900 rounded-lg flex items-center justify-center overflow-hidden relative cursor-crosshair">
                            <svg id="graph-svg" width="100%" height="100%"></svg>
                            <p id="empty-message" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-slate-400 text-center w-full px-4">Clique na tela para adicionar um nó.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Conteúdo da Aba de Quiz -->
            <div id="quiz-content" class="hidden text-center">
                 <div id="quiz-selection-screen">
                    <h2>Quiz sobre Grafos</h2>
                    <p class="my-4">Teste seus conhecimentos. Escolha um dos quizzes abaixo para começar.</p>
                    <div id="quiz-buttons-container" class="flex flex-col gap-4 mx-auto max-w-xs">
                        <!-- Buttons will be generated here -->
                    </div>
                </div>
                <div id="quiz-container" class="hidden">
                    <div id="quiz-progress" class="text-sm text-slate-400 mb-2 text-right"></div>
                    <p id="quiz-question" class="text-xl font-semibold mb-4 text-left"></p>
                    <div id="quiz-options" class="space-y-3"></div>
                    <div id="quiz-explanation" class="hidden mt-4 p-3 bg-slate-700 rounded-lg text-left text-sm"></div>
                    <button id="next-question-btn" class="hidden mt-6 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg">Próxima Pergunta</button>
                </div>
                <div id="quiz-results-screen" class="hidden">
                    <h2>Quiz Finalizado!</h2>
                    <p class="my-4 text-lg">Sua pontuação foi:</p>
                    <p id="quiz-score" class="text-4xl font-bold text-indigo-400"></p>
                    <div class="flex justify-center gap-4 mt-8">
                        <button id="restart-quiz-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 transform hover:scale-105">Tentar Novamente este Quiz</button>
                        <button id="back-to-quizzes-btn" class="bg-slate-600 hover:bg-slate-500 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 transform hover:scale-105">Ver Outros Quizzes</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- Classes e Variáveis Globais ---
        const svg = document.getElementById('graph-svg');
        const emptyMessage = document.getElementById('empty-message');
        const controlsFieldset = document.getElementById('controls-fieldset');
        const algorithmSelect = document.getElementById('algorithm-select');
        const startNodeInput = document.getElementById('start-node-input');
        const endNodeInput = document.getElementById('end-node-input');
        const runAlgorithmBtn = document.getElementById('run-algorithm-btn');
        const algorithmInfo = document.getElementById('algorithm-info');
        const generateRandomGraphBtn = document.getElementById('generate-random-graph-btn');
        const sidebarWrapper = document.getElementById('sidebar-wrapper');

        // State
        let nodes = new Map(); // Map<id, {x, y, el}>
        let edges = new Map(); // Map<"from-to", {from, to, weight, el, labelEl}>
        let adj = new Map();   // Map<id, Set<id>>
        let nextNodeId = 1;

        let selectedNode = null;
        let draggingNode = null;
        let isRemovingNode = false;

        // --- Lógica de Manipulação do Grafo ---

        function addNode(cx, cy) {
            const id = nextNodeId++;
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.id = `node-${id}`;
            g.classList.add('node');
            g.style.cursor = 'move';
            g.setAttribute('transform', `translate(${cx}, ${cy})`);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('r', 15);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('y', 5);
            text.setAttribute('text-anchor', 'middle');
            text.textContent = id;

            g.appendChild(circle);
            g.appendChild(text);
            svg.appendChild(g);

            const nodeData = { id, x: cx, y: cy, el: g };
            nodes.set(id, nodeData);
            adj.set(id, new Map());

            g.addEventListener('mousedown', (e) => onNodeMouseDown(e, nodeData));
            g.addEventListener('click', (e) => onNodeClick(e, nodeData));

            updateEmptyMessage();
            return nodeData;
        }

        function removeNode(id) {
            if (!nodes.has(id)) return;

            // Remove edges connected to this node
            const edgesToRemove = [];
            for (const [key, edge] of edges.entries()) {
                if (edge.from === id || edge.to === id) {
                    edgesToRemove.push(key);
                }
            }
            edgesToRemove.forEach(removeEdgeByKey);

            // Remove node from adjacency lists of other nodes
            for (const neighbors of adj.values()) {
                for(const neighborId of neighbors.keys()){
                     if(neighborId === id) {
                        neighbors.delete(neighborId);
                     }
                }
            }

            adj.delete(id);
            const node = nodes.get(id);
            svg.removeChild(node.el);
            nodes.delete(id);

            updateEmptyMessage();
        }

        function addEdge(fromId, toId, weight) {
            fromId = parseInt(fromId);
            toId = parseInt(toId);

            if (fromId === toId || !nodes.has(fromId) || !nodes.has(toId)) return;

            const key1 = `${fromId}-${toId}`;
            const key2 = `${toId}-${fromId}`;
            if (edges.has(key1) || edges.has(key2)) return; // Edge already exists

            const fromNode = nodes.get(fromId);
            const toNode = nodes.get(toId);

            // Add to adjacency list (undirected graph)
            adj.get(fromId).set(toId, weight);
            adj.get(toId).set(fromId, weight);

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.classList.add('edge');
            line.setAttribute('x1', fromNode.x);
            line.setAttribute('y1', fromNode.y);
            line.setAttribute('x2', toNode.x);
            line.setAttribute('y2', toNode.y);

            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.classList.add('edge-label');
            label.textContent = weight;

            svg.prepend(label);
            svg.prepend(line);

            const edgeData = { from: fromId, to: toId, weight, el: line, labelEl: label };
            edges.set(key1, edgeData);

            updateEdgePosition(key1);
        }

        function removeEdge(fromId, toId) {
            fromId = parseInt(fromId);
            toId = parseInt(toId);

            const key1 = `${fromId}-${toId}`;
            const key2 = `${toId}-${fromId}`;
            removeEdgeByKey(key1);
            removeEdgeByKey(key2);

            // Remove from adjacency list
            if (adj.has(fromId)) adj.get(fromId).delete(toId);
            if (adj.has(toId)) adj.get(toId).delete(fromId);
        }

        function removeEdgeByKey(key) {
            if (edges.has(key)) {
                const edge = edges.get(key);
                svg.removeChild(edge.el);
                if (edge.labelEl) svg.removeChild(edge.labelEl);
                edges.delete(key);
            }
        }

        function generateRandomGraph() {
            // Clear existing graph
            nodes.clear();
            edges.clear();
            adj.clear();
            svg.innerHTML = '';
            nextNodeId = 1;

            const numNodes = parseInt(document.getElementById('random-nodes-input').value) || 5;
            const numEdges = parseInt(document.getElementById('random-edges-input').value) || 4;
            const containerRect = document.getElementById('visualization-container').getBoundingClientRect();

            // Add nodes at random positions
            const generatedNodeIds = [];
            for (let i = 0; i < numNodes; i++) {
                const padding = 30;
                const x = Math.random() * (containerRect.width - padding * 2) + padding;
                const y = Math.random() * (containerRect.height - padding * 2) + padding;
                const newNode = addNode(x, y);
                generatedNodeIds.push(newNode.id);
            }

            // Add edges between random nodes
            if (generatedNodeIds.length < 2) {
                updateEmptyMessage();
                return;
            }

            const maxPossibleEdges = numNodes * (numNodes - 1) / 2;
            const edgesToCreate = Math.min(numEdges, maxPossibleEdges);
            const existingEdges = new Set();

            for (let i = 0; i < edgesToCreate; i++) {
                let fromId, toId, key1, key2;
                let attempts = 0;
                const maxAttempts = 50; // To prevent infinite loop if all edges are created

                // Find a unique pair of nodes
                do {
                    fromId = generatedNodeIds[Math.floor(Math.random() * generatedNodeIds.length)];
                    toId = generatedNodeIds[Math.floor(Math.random() * generatedNodeIds.length)];
                    key1 = `${fromId}-${toId}`;
                    key2 = `${toId}-${fromId}`;
                    attempts++;
                } while ((fromId === toId || existingEdges.has(key1) || existingEdges.has(key2)) && attempts < maxAttempts);

                if (attempts < maxAttempts) {
                    const weight = Math.floor(Math.random() * 10) + 1;
                    addEdge(fromId, toId, weight);
                    existingEdges.add(key1);
                    existingEdges.add(key2);
                }
            }
            updateEmptyMessage();
        }

        // --- Lógica de Visualização e Interação ---

        function updateEmptyMessage() {
            emptyMessage.style.display = nodes.size === 0 ? 'block' : 'none';
        }

        function updateEdgePosition(key) {
             if (!edges.has(key)) return;
             const edge = edges.get(key);
             const fromNode = nodes.get(edge.from);
             const toNode = nodes.get(edge.to);

             edge.el.setAttribute('x1', fromNode.x);
             edge.el.setAttribute('y1', fromNode.y);
             edge.el.setAttribute('x2', toNode.x);
             edge.el.setAttribute('y2', toNode.y);

             if (edge.labelEl) {
                 edge.labelEl.setAttribute('x', (fromNode.x + toNode.x) / 2);
                 edge.labelEl.setAttribute('y', (fromNode.y + toNode.y) / 2 - 5);
             }
         }

        function onNodeMouseDown(event, nodeData) {
            event.preventDefault();
            if (isRemovingNode) return;
            draggingNode = nodeData;
            draggingNode.el.classList.add('dragging');
        }

        function onNodeClick(event, nodeData) {
              event.stopPropagation(); // Prevent canvas click
              if (isRemovingNode) {
                  removeNode(nodeData.id);
                  isRemovingNode = false;
                  svg.style.cursor = 'crosshair';
                  document.getElementById('remove-node-btn').classList.remove('active', 'bg-red-800');
              }
         }

        function onMouseMove(event) {
            if (!draggingNode) return;
            const coords = getSVGCoordinates(event);
            draggingNode.x = coords.x;
            draggingNode.y = coords.y;
            draggingNode.el.setAttribute('transform', `translate(${draggingNode.x}, ${draggingNode.y})`);

            // Update connected edges
            for (const [key, edge] of edges.entries()) {
                if (edge.from === draggingNode.id || edge.to === draggingNode.id) {
                    updateEdgePosition(key);
                }
            }
        }

        function onMouseUp() {
            if (draggingNode) {
                draggingNode.el.classList.remove('dragging');
            }
            draggingNode = null;
        }

        function onCanvasClick(event) {
            if (isRemovingNode) { // Clicked away, cancel removal
                  isRemovingNode = false;
                  svg.style.cursor = 'crosshair';
                  document.getElementById('remove-node-btn').classList.remove('active', 'bg-red-800');
                  return;
            }
            if (event.target.tagName !== 'svg') return;
            const coords = getSVGCoordinates(event);
            addNode(coords.x, coords.y);
        }

        function getSVGCoordinates(event) {
            const pt = svg.createSVGPoint();
            pt.x = event.clientX;
            pt.y = event.clientY;
            return pt.matrixTransform(svg.getScreenCTM().inverse());
        }

        function clearAllHighlights() {
            nodes.forEach(node => node.el.classList.remove('visited', 'current', 'path'));
            edges.forEach(edge => edge.el.classList.remove('highlighted', 'path'));
        }

        // --- Lógica dos Algoritmos ---

        async function runAnimation(steps) {
            controlsFieldset.disabled = true;
            clearAllHighlights();
            await new Promise(r => setTimeout(r, 200));

            for(const step of steps) {
                 clearCurrentHighlights(); // Clear previous 'current' state

                switch(step.action) {
                    case 'visit':
                        nodes.get(step.nodeId).el.classList.add('visited');
                        break;
                    case 'current':
                        nodes.get(step.nodeId).el.classList.add('current');
                        break;
                    case 'highlight-edge': {
                        const key1 = `${step.from}-${step.to}`;
                        const key2 = `${step.to}-${step.from}`;
                        const edge = edges.get(key1) || edges.get(key2);
                        if (edge) edge.el.classList.add('highlighted');
                        break;
                    }
                    case 'path': {
                        const key1 = `${step.from}-${step.to}`;
                        const key2 = `${step.to}-${step.from}`;
                        const edge = edges.get(key1) || edges.get(key2);
                        if (edge) {
                            edge.el.classList.add('path');
                            nodes.get(step.from).el.classList.add('path');
                            nodes.get(step.to).el.classList.add('path');
                        }
                        break;
                    }
                }
                await new Promise(r => setTimeout(r, 700));
            }
            controlsFieldset.disabled = false;
        }

        function clearCurrentHighlights(){
             nodes.forEach(node => node.el.classList.remove('current'));
             edges.forEach(edge => edge.el.classList.remove('highlighted'));
        }

        function bfs(startId) {
            const steps = [];
            if (!nodes.has(startId)) return steps;

            const queue = [startId];
            const visited = new Set([startId]);

            steps.push({ action: 'visit', nodeId: startId });

            while (queue.length > 0) {
                const u = queue.shift();
                steps.push({ action: 'current', nodeId: u });
                const neighbors = Array.from(adj.get(u).keys());

                for (const v of neighbors) {
                    if (!visited.has(v)) {
                        visited.add(v);
                        queue.push(v);
                        steps.push({ action: 'highlight-edge', from: u, to: v });
                        steps.push({ action: 'visit', nodeId: v });
                    }
                }
            }
            return steps;
        }

        function dfs(startId) {
            const steps = [];
            if (!nodes.has(startId)) return steps;

            const visited = new Set();
            const stack = [startId];

            while(stack.length > 0) {
                const u = stack.pop();

                if(!visited.has(u)) {
                    visited.add(u);
                    steps.push({ action: 'current', nodeId: u });
                    steps.push({ action: 'visit', nodeId: u });

                    const neighbors = Array.from(adj.get(u).keys()).reverse(); // To explore in ascending order
                    for (const v of neighbors) {
                        if (!visited.has(v)) {
                            stack.push(v);
                            steps.push({ action: 'highlight-edge', from: u, to: v });
                        }
                    }
                }
            }
            return steps;
        }

        function dijkstra(startId, endId) {
            const steps = [];
            if (!nodes.has(startId)) return steps;

            const dist = new Map();
            const prev = new Map();
            const pq = new Map(); // Using a map as a simple priority queue

            for (const id of nodes.keys()) {
                dist.set(id, Infinity);
                prev.set(id, null);
                pq.set(id, Infinity);
            }

            dist.set(startId, 0);
            pq.set(startId, 0);

            while (pq.size > 0) {
                // Get node with smallest distance from PQ
                let u = null;
                let min_dist = Infinity;
                for(const [nodeId, d] of pq.entries()){
                    if (d < min_dist){
                        min_dist = d;
                        u = nodeId;
                    }
                }
                if (u === null) break; // All remaining nodes are inaccessible
                pq.delete(u);

                steps.push({ action: 'current', nodeId: u });

                if (u === endId) break;

                const neighbors = adj.get(u);
                for (const [v, weight] of neighbors.entries()) {
                     steps.push({ action: 'highlight-edge', from: u, to: v });
                    const alt = dist.get(u) + weight;
                    if (alt < dist.get(v)) {
                        dist.set(v, alt);
                        prev.set(v, u);
                        pq.set(v, alt);
                    }
                }
                 steps.push({ action: 'visit', nodeId: u });
            }

            // Reconstruct path
            if (endId && prev.has(endId)) {
                let current = endId;
                while (current !== null) {
                    const p = prev.get(current);
                    if (p !== null) {
                        steps.push({ action: 'path', from: p, to: current });
                    }
                    current = p;
                }
            }

            return steps;
        }

        // --- Lógica de Controle e Event Listeners ---

        document.getElementById('add-node-btn').addEventListener('click', () => {
             isRemovingNode = false;
             svg.style.cursor = 'crosshair';
             document.getElementById('remove-node-btn').classList.remove('active', 'bg-red-800');
        });

        document.getElementById('remove-node-btn').addEventListener('click', (e) => {
             isRemovingNode = !isRemovingNode;
             if(isRemovingNode) {
                 svg.style.cursor = 'not-allowed';
                 e.target.classList.add('active', 'bg-red-800');
             } else {
                 svg.style.cursor = 'crosshair';
                 e.target.classList.remove('active', 'bg-red-800');
             }
        });

        document.getElementById('add-edge-btn').addEventListener('click', () => {
            const fromId = document.getElementById('from-node-input').value;
            const toId = document.getElementById('to-node-input').value;
            const weight = parseInt(document.getElementById('weight-input').value) || 1;
            if (fromId && toId) addEdge(fromId, toId, weight);
        });

        document.getElementById('remove-edge-btn').addEventListener('click', () => {
            const fromId = document.getElementById('from-node-input').value;
            const toId = document.getElementById('to-node-input').value;
            if (fromId && toId) removeEdge(fromId, toId);
        });

        document.getElementById('clear-graph-btn').addEventListener('click', () => {
            nodes.clear();
            edges.clear();
            adj.clear();
            svg.innerHTML = '';
            nextNodeId = 1;
            updateEmptyMessage();
        });

        algorithmSelect.addEventListener('change', () => {
            endNodeInput.style.display = algorithmSelect.value === 'dijkstra' ? 'block' : 'none';
        });

        runAlgorithmBtn.addEventListener('click', () => {
            const algo = algorithmSelect.value;
            const startId = parseInt(startNodeInput.value);

            let steps = [];
            switch (algo) {
                case 'bfs':
                    steps = bfs(startId);
                    break;
                case 'dfs':
                    steps = dfs(startId);
                    break;
                case 'dijkstra':
                    const endId = parseInt(endNodeInput.value);
                    steps = dijkstra(startId, endId);
                    break;
            }
            if (steps.length > 0) {
                 runAnimation(steps);
            } else {
                alert("Nó inicial inválido ou não encontrado.");
            }
        });

        generateRandomGraphBtn.addEventListener('click', generateRandomGraph);

        svg.addEventListener('mousedown', onCanvasClick);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);

        // --- Lógica de Abas ---
        const practiceContent = document.getElementById('practice-content');
        const theoryContent = document.getElementById('theory-content');
        const quizContent = document.getElementById('quiz-content');
        const tabPractice = document.getElementById('tab-practice');
        const tabTheory = document.getElementById('tab-theory');
        const tabQuiz = document.getElementById('tab-quiz');

        function switchTab(tabId) {
            [practiceContent, theoryContent, quizContent].forEach(c => c.classList.add('hidden'));
            [tabPractice, tabTheory, tabQuiz].forEach(t => t.classList.remove('active'));

            document.getElementById(tabId).classList.remove('hidden');
            document.querySelector(`[id=tab-${tabId.split('-')[0]}]`).classList.add('active');

            if(sidebarWrapper){
                 if (tabId === 'theory-content') {
                    sidebarWrapper.classList.remove('invisible');
                } else {
                    sidebarWrapper.classList.add('invisible');
                }
            }

             if (tabId === 'quiz-content') {
                document.getElementById('quiz-container').classList.add('hidden');
                document.getElementById('quiz-results-screen').classList.add('hidden');
                document.getElementById('quiz-selection-screen').classList.remove('hidden');
             }
        }

        tabPractice.addEventListener('click', () => switchTab('practice-content'));
        tabTheory.addEventListener('click', () => switchTab('theory-content'));
        tabQuiz.addEventListener('click', () => switchTab('quiz-content'));


        // --- Lógica do QUIZ ---
        const quizQuestions = [
            // Quiz 1: Conceitos Básicos
            { type: 'theory', question: 'Em teoria dos grafos, o que um vértice representa?', options: ['Uma conexão', 'Uma entidade ou objeto', 'Uma direção', 'Um peso'], correctAnswer: 'Uma entidade ou objeto', explanation: 'Vértices (ou nós) são os elementos fundamentais que representam os objetos em um grafo.' },
            { type: 'theory', question: 'O que é um grafo ponderado?', options: ['Um grafo com muitas arestas', 'Um grafo onde as arestas têm um valor (peso) associado', 'Um grafo onde os vértices têm cores', 'Um grafo sem ciclos'], correctAnswer: 'Um grafo onde as arestas têm um valor (peso) associado', explanation: 'O peso pode representar custo, distância, tempo, etc.' },
            { type: 'theory', question: 'Qual a principal diferença entre um grafo direcionado e um não-direcionado?', options: ['O número de vértices', 'A presença de pesos', 'A direção das arestas', 'A cor dos nós'], correctAnswer: 'A direção das arestas', explanation: 'Em grafos direcionados, uma aresta A -> B não implica B -> A. Em não-direcionados, a conexão é mútua.' },
            { type: 'theory', question: 'Qual algoritmo de busca explora o grafo em "camadas", visitando todos os vizinhos primeiro?', options: ['Busca em Profundidade (DFS)', 'Algoritmo de Dijkstra', 'Busca em Largura (BFS)', 'Algoritmo de Prim'], correctAnswer: 'Busca em Largura (BFS)', explanation: 'A BFS usa uma fila para garantir que os nós mais próximos do início sejam visitados primeiro.' },
            { type: 'theory', question: 'Qual estrutura de dados é comumente associada à Busca em Profundidade (DFS)?', options: ['Fila', 'Pilha', 'Heap', 'Tabela Hash'], correctAnswer: 'Pilha', explanation: 'A DFS usa uma pilha (seja explícita ou via recursão) para seguir um caminho o mais fundo possível antes de retroceder.' },
            { type: 'theory', question: 'O Algoritmo de Dijkstra é usado para resolver qual tipo de problema?', options: ['Encontrar todos os ciclos em um grafo', 'Encontrar a Árvore Geradora Mínima', 'Encontrar o caminho mais curto em um grafo ponderado', 'Verificar se um grafo é bipartido'], correctAnswer: 'Encontrar o caminho mais curto em um grafo ponderado', explanation: 'Dijkstra é o algoritmo clássico para caminhos mais curtos, desde que os pesos das arestas não sejam negativos.' },

            // Quiz 2: Algoritmos
            { type: 'theory', question: 'Para qual tipo de grafo a BFS garante encontrar o caminho mais curto?', options: ['Qualquer grafo ponderado', 'Apenas grafos direcionados', 'Grafos não-ponderados', 'Grafos com pesos negativos'], correctAnswer: 'Grafos não-ponderados', explanation: 'Como a BFS explora em camadas, o primeiro caminho que ela encontra para um nó é garantido ser o mais curto em termos de número de arestas.' },
            { type: 'theory', question: 'Qual algoritmo usa uma fila de prioridade para funcionar eficientemente?', options: ['Busca em Largura (BFS)', 'Busca em Profundidade (DFS)', 'Detecção de Ciclos', 'Algoritmo de Dijkstra'], correctAnswer: 'Algoritmo de Dijkstra', explanation: 'Dijkstra usa uma fila de prioridade para sempre selecionar o nó não visitado com a menor distância acumulada do início.' },
            { type: 'theory', question: 'Se você precisa verificar se existe um caminho entre dois nós, qual algoritmo seria uma escolha simples e eficiente?', options: ['Dijkstra', 'Floyd-Warshall', 'BFS ou DFS', 'Kruskal'], correctAnswer: 'BFS ou DFS', explanation: 'Tanto a BFS quanto a DFS podem determinar a conectividade entre nós. A BFS encontrará o caminho mais curto (em arestas), enquanto a DFS pode ser mais rápida em alguns casos.' },
            { type: 'theory', question: 'O que acontece se você executar o Algoritmo de Dijkstra em um grafo com pesos de aresta negativos?', options: ['Ele funciona normalmente', 'Ele pode produzir uma resposta incorreta', 'Ele entra em um loop infinito', 'Ele se transforma em uma BFS'], correctAnswer: 'Ele pode produzir uma resposta incorreta', explanation: 'A premissa de Dijkstra é que, uma vez que um nó é finalizado, seu caminho mais curto foi encontrado. Pesos negativos podem violar essa premissa.' },
            { type: 'theory', question: 'Em uma Busca em Largura (BFS) partindo de um nó A, quais nós são visitados imediatamente após A?', options: ['Todos os nós do grafo', 'Nenhum nó', 'Os vizinhos diretos de A', 'O nó mais distante de A'], correctAnswer: 'Os vizinhos diretos de A', explanation: 'A BFS visita primeiro todos os nós que estão a uma aresta de distância do nó inicial.' },
            { type: 'theory', question: 'Qual a principal aplicação da Busca em Profundidade (DFS)?', options: ['Encontrar o caminho mais curto em grafos ponderados', 'Calcular a distância entre todos os pares de nós', 'Detecção de ciclos e ordenação topológica', 'Balanceamento de grafos'], correctAnswer: 'Detecção de ciclos e ordenação topológica', explanation: 'A natureza de "ir fundo" da DFS a torna excelente para explorar caminhos e detectar "back edges", que indicam ciclos.' },
        ];
        const quizStartScreen = document.getElementById('quiz-selection-screen');
        const quizContainer = document.getElementById('quiz-container');
        const quizResultsScreen = document.getElementById('quiz-results-screen');
        const restartQuizBtn = document.getElementById('restart-quiz-btn');
        const backToQuizzesBtn = document.getElementById('back-to-quizzes-btn');
        const quizQuestionEl = document.getElementById('quiz-question');
        const quizOptionsEl = document.getElementById('quiz-options');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const quizProgressEl = document.getElementById('quiz-progress');
        const quizScoreEl = document.getElementById('quiz-score');
        const quizExplanationEl = document.getElementById('quiz-explanation');

        let shuffledQuestions, currentQuestionIndex, score, currentQuizNumber;

        function startQuiz(quizNum) {
            currentQuizNumber = quizNum;
            quizStartScreen.classList.add('hidden');
            quizResultsScreen.classList.add('hidden');
            quizContainer.classList.remove('hidden');

            const questionsPerQuiz = 6;
            const startIndex = (quizNum - 1) * questionsPerQuiz;
            const endIndex = startIndex + questionsPerQuiz;
            const questionSubset = quizQuestions.slice(startIndex, endIndex);

            shuffledQuestions = questionSubset.sort(() => Math.random() - 0.5);
            currentQuestionIndex = 0;
            score = 0;
            displayNextQuestion();
        }

        function displayNextQuestion() {
            resetQuizState();
            if (currentQuestionIndex >= shuffledQuestions.length) {
                showQuizResults();
                return;
            }
            quizProgressEl.textContent = `Pergunta ${currentQuestionIndex + 1} de ${shuffledQuestions.length}`;
            const questionData = shuffledQuestions[currentQuestionIndex];
            quizQuestionEl.textContent = questionData.question;

            questionData.options.forEach(optionText => {
                const button = document.createElement('button');
                button.textContent = optionText;
                button.className = 'quiz-option';
                button.onclick = () => selectAnswer(button, optionText, questionData.correctAnswer);
                quizOptionsEl.appendChild(button);
            });
        }

        function selectAnswer(buttonEl, selectedAnswer, correctAnswer) {
            const allOptions = quizOptionsEl.querySelectorAll('.quiz-option');
            allOptions.forEach(btn => {
                btn.disabled = true;
                if (btn.textContent === correctAnswer) {
                    btn.classList.add('correct');
                }
            });

            if (selectedAnswer === correctAnswer) {
                score++;
            } else {
                buttonEl.classList.add('incorrect');
            }

            const questionData = shuffledQuestions[currentQuestionIndex];
            if (questionData.explanation) {
                quizExplanationEl.innerHTML = `<strong>Explicação:</strong> ${questionData.explanation}`;
                quizExplanationEl.classList.remove('hidden');
            }

            nextQuestionBtn.classList.remove('hidden');
        }

        function resetQuizState() {
            quizOptionsEl.innerHTML = '';
            quizExplanationEl.classList.add('hidden');
            nextQuestionBtn.classList.add('hidden');
        }

        function showQuizResults() {
            quizContainer.classList.add('hidden');
            quizResultsScreen.classList.remove('hidden');
            quizScoreEl.textContent = `${score} / ${shuffledQuestions.length}`;
        }

        nextQuestionBtn.addEventListener('click', () => {
            currentQuestionIndex++;
            displayNextQuestion();
        });
        restartQuizBtn.addEventListener('click', () => startQuiz(currentQuizNumber));
        backToQuizzesBtn.addEventListener('click', () => {
            quizResultsScreen.classList.add('hidden');
            document.getElementById('quiz-selection-screen').classList.remove('hidden');
        });

        function setupQuizSelection() {
            const container = document.getElementById('quiz-buttons-container');
            container.innerHTML = '';
            const numQuizzes = Math.ceil(quizQuestions.length / 6);
            const quizNames = ["Conceitos Básicos", "Algoritmos"];
            for (let i = 1; i <= numQuizzes; i++) {
                const button = document.createElement('button');
                button.textContent = `Quiz ${i}: ${quizNames[i-1] || ''}`;
                button.className = 'bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 transform hover:scale-105';
                button.onclick = () => startQuiz(i);
                container.appendChild(button);
            }
        }


        // --- Inicialização ---
        updateEmptyMessage();
        switchTab('theory-content');
        setupQuizSelection();

    </script>
</body>
</html>
