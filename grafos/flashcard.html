<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcards de Teoria dos Grafos</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            /* AJUSTE: Fundo igual ao da aplicação principal */
            background-color: #111827;
        }

        .katex-display { margin: 0.5em 0 !important; }
        .katex { color: #f1f5f9; }

        .card-container {
            perspective: 1000px;
            width: 100%;
            max-width: 400px;
            height: 250px;
            margin: 0 auto;
        }

        .flashcard {
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            position: relative;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            border-radius: 1rem;
        }

        .flashcard.flipped { transform: rotateY(180deg); }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            border-radius: 1rem;
            text-align: center;
            word-wrap: break-word;
            overflow-y: auto;
        }

        .card-front {
            background-color: #334155; /* Slate-700 */
            color: #f1f5f9;
            font-size: 1.25rem;
            font-weight: 600;
        }

        .card-back {
            /* AJUSTE: Cor de destaque alterada para indigo */
            background-color: #4f46e5; /* Indigo-600 */
            color: #ffffff;
            transform: rotateY(180deg);
            font-size: 1rem;
            font-weight: 400;
        }

        .card-back strong { font-weight: 700; }
        .card-face::-webkit-scrollbar { width: 6px; }
        .card-face::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        .card-content-wrapper {
            width: 100%;
            text-align: center;
        }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
</head>

<body class="p-4 sm:p-8">

    <div class="w-full max-w-7xl mx-auto bg-slate-800 text-slate-200 rounded-2xl shadow-lg p-6 sm:p-10">

        <a href="https://ana-borowsky.github.io/grafos/" class="text-indigo-400 hover:text-indigo-300 mb-6 inline-block">&larr; Voltar para o Guia</a>

        <h1 class="text-3xl font-bold text-slate-100 text-center mb-6">Flashcards: Teoria dos Grafos</h1>
        <p class="text-center text-slate-400 mb-8">Estude os conceitos fundamentais da Teoria dos Grafos.</p>

        <div class="mb-8 flex flex-col sm:flex-row items-center justify-center space-y-4 sm:space-y-0 sm:space-x-4">
            <label for="topic-select" class="text-lg font-medium text-slate-300">Escolha o Tópico:</label>
            <select id="topic-select"
                class="p-3 bg-slate-700 text-white border border-slate-600 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 w-full sm:w-auto">
            </select>
        </div>

        <div class="card-container mb-6">
            <div id="flashcard" class="flashcard">
                <div id="card-front" class="card-face card-front shadow-lg">
                    <p class="text-slate-400">Selecione um tópico para começar!</p>
                </div>
                <div id="card-back" class="card-face card-back shadow-lg">
                    <p>Resposta</p>
                </div>
            </div>
        </div>

        <div class="text-center mb-6 text-slate-400 font-medium" id="progress-indicator">
            0/0
        </div>

        <div class="flex flex-col space-y-4 sm:space-y-0 sm:flex-row sm:justify-center sm:space-x-4">
            <button id="prev-button"
                class="bg-slate-600 text-white px-6 py-3 rounded-lg font-semibold shadow-md transition-all hover:bg-slate-700 disabled:opacity-50"
                disabled>
                Anterior
            </button>
            <button id="flip-button"
                class="bg-indigo-600 text-white px-6 py-3 rounded-lg font-semibold shadow-md transition-all hover:bg-indigo-700 disabled:opacity-50"
                disabled>
                Virar Cartão
            </button>
            <button id="next-button"
                class="bg-indigo-600 text-white px-6 py-3 rounded-lg font-semibold shadow-md transition-all hover:bg-indigo-700 disabled:opacity-50"
                disabled>
                Próximo
            </button>
        </div>
    </div>

    <script>
        const flashcardData = {
            "Conceitos Fundamentais": [
                { q: "O que é um **Grafo**?", a: "É um conjunto de **nós** (ou vértices) e um conjunto de **arestas** que conectam pares desses nós." },
                { q: "Qual a diferença entre um grafo **direcionado** e um **não-direcionado**?", a: "Em um grafo **não-direcionado**, as arestas são mútuas. Em um **direcionado**, as arestas têm um sentido." },
                { q: "O que caracteriza um **Grafo Ponderado**?", a: "As arestas possuem um valor numérico." },
                { q: "O que é um **Grafo Simples**?", a: "É um tipo de grafo que **não possui laços** (arestas que conectam um vértice a si mesmo) nem arestas múltiplas." },
                { q: "O que é um **Grafo Conexo**?", a: "É um grafo onde existe um caminho entre **qualquer par de vértices**." },
                { q: "O que é o **grau de um vértice**?", a: "Quantidade de arestas que estão ligadas a ele." },
                { q: "O que é um **ciclo** em um grafo?", a: "É um caminho que começa e termina no mesmo nó." }
            ],
            "Busca em Grafos": [
                { q: "Quais as vantagens e desvantagens da **Busca em Largura (BFS)** vs. **Busca em Profundidade (DFS)**?", a: "BFS encontra o caminho mais curto (em arestas) e lida bem com ciclos, mas usa mais memória (fila). DFS é mais simples e usa menos memória (pilha/recursão), mas pode não encontrar o caminho mais curto e precisa de controle de 'visitados' para evitar loops." },
                { q: "Qual a estrutura de dados central na **Busca em Profundidade (DFS)**?", a: "Uma **Pilha**, geralmente implementada por meio de **recursão**." },
                { q: "Qual a estrutura de dados central na **Busca em Largura (BFS)**?", a: "Uma **Fila**, pois visita o grafo em camadas de distância (FIFO)." }
            ],
            "Coloração e Planaridade": [
                { q: "O que é o problema da **coloração de grafos**?", a: "Atribuir cores aos vértices de modo que dois vértices vizinhos **nunca tenham a mesma cor**." },
                { q: "O que diz o **Teorema das Quatro Cores**?", a: "Qualquer mapa (grafo planar) pode ser colorido com no máximo **quatro cores**." },
                { q: "O que é o **número cromático**?", a: "É o **menor número de cores** necessárias para colorir um grafo." },
                { q: "O que é um **Grafo Planar**?", a: "É um grafo que pode ser desenhado em um plano **sem que nenhuma de suas arestas se cruze**." },
                { q: "Qual teoria ajuda a verificar se um grafo possui cruzamentos?", a: "A Teoria dos Grafos Planos, especialmente o **Teorema de Kuratowski**, que usa os grafos $K_5$ e $K_{3,3}$ como base para a não-planaridade." },
                { q: "Qual a relação entre grafos **completos** e **cruzamento de arestas**?", a: "Qualquer grafo completo com 5 ou mais vértices (ex: $K_5$, $K_6$) é **sempre não-planar**." }
            ],
            "Caminhos e Ciclos Especiais": [
                { q: "Quando um grafo possui um **Circuito Euleriano**?", a: "Quando o grafo é conexo e **todos os seus vértices têm grau par**. Um circuito euleriano passa por todas as arestas uma vez e volta ao início." },
                { q: "O que é um **Ciclo Hamiltoniano**?", a: "É um ciclo que visita **todos os vértices** de um grafo exatamente uma vez, começando e terminando no mesmo vértice." },
                { q: "O **Problema do Caixeiro-Viajante** está relacionado a qual conceito?", a: "Está relacionado à busca por um **ciclo hamiltoniano** que também **minimiza a distância total** percorrida." }
            ],
            "Isomorfismo e Aplicações": [
                { q: "Como é possível identificar se dois grafos representam a **mesma estrutura**?", a: "Através da teoria do **isomorfismo**, que verifica se existe uma correspondência entre os vértices que preserva as conexões (arestas)." },
                { q: "Existe um algoritmo eficiente (tempo polinomial) para determinar se dois grafos são **isomorfos**?", a: "Não, é um problema famoso para o qual **não se conhece um algoritmo determinístico de tempo polinomial**." },
                { q: "Quando o algoritmo de **Huffman** funciona bem para compactação?", a: "Funciona bem quando a **frequência dos caracteres** varia bastante." },
                { q: "Qual a relação entre a frequência de um caractere e o tamanho do seu código de **Huffman**?", a: "Quanto **mais frequente** é o caractere, **menor** será o código binário atribuído a ele, e vice-versa." }
            ]
        };

        let currentCategory = null;
        let currentCards = [];
        let currentIndex = 0;
        let isFlipped = false;

        const topicSelect = document.getElementById('topic-select');
        const flashcardElement = document.getElementById('flashcard');
        const cardFront = document.getElementById('card-front');
        const cardBack = document.getElementById('card-back');
        const flipButton = document.getElementById('flip-button');
        const prevButton = document.getElementById('prev-button');
        const nextButton = document.getElementById('next-button');
        const progressIndicator = document.getElementById('progress-indicator');

        function renderKaTeX(element) {
            const content = element.innerHTML;
            const replacedContent = content.replace(/\$(.*?)\$/g, (match, expression) => {
                try {
                    return katex.renderToString(expression.trim(), {
                        throwOnError: false,
                        displayMode: false
                    });
                } catch (e) {
                    console.error("KaTeX rendering error:", e);
                    return match;
                }
            });
            element.innerHTML = replacedContent;
        }

        function updateCardContent() {
            if (currentCards.length === 0) {
                cardFront.innerHTML = '<p class="text-slate-400">Selecione um tópico para começar!</p>';
                cardBack.innerHTML = '<p>Resposta</p>';
                progressIndicator.textContent = '0/0';
                return;
            }

            const card = currentCards[currentIndex];
            const frontText = card.q.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            const backText = card.a.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

            cardFront.innerHTML = `<div class="card-content-wrapper">${frontText}</div>`;
            cardBack.innerHTML = `<div class="card-content-wrapper">${backText}</div>`;

            if (typeof katex !== 'undefined') {
                const frontWrapper = cardFront.querySelector('.card-content-wrapper');
                const backWrapper = cardBack.querySelector('.card-content-wrapper');
                if (frontWrapper) renderKaTeX(frontWrapper);
                if (backWrapper) renderKaTeX(backWrapper);
            }

            progressIndicator.textContent = `${currentIndex + 1}/${currentCards.length}`;
            flashcardElement.classList.remove('flipped');
            isFlipped = false;
            prevButton.disabled = currentIndex === 0;
            nextButton.disabled = currentIndex === currentCards.length - 1;
            flipButton.disabled = false;
        }

        function flipCard() {
            if (currentCards.length === 0) return;
            isFlipped = !isFlipped;
            flashcardElement.classList.toggle('flipped', isFlipped);
        }

        function nextCard() {
            if (currentIndex < currentCards.length - 1) {
                currentIndex++;
                updateCardContent();
            }
        }

        function prevCard() {
            if (currentIndex > 0) {
                currentIndex--;
                updateCardContent();
            }
        }

        function loadCategory(categoryName) {
            currentCategory = categoryName;
            currentCards = flashcardData[categoryName] || [];
            currentIndex = 0;
            updateCardContent();
        }

        document.addEventListener('DOMContentLoaded', () => {
            Object.keys(flashcardData).forEach(topic => {
                const option = document.createElement('option');
                option.value = topic;
                option.textContent = topic;
                topicSelect.appendChild(option);
            });

            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "--- Selecione um Tópico ---";
            defaultOption.disabled = true;
            defaultOption.selected = true;
            topicSelect.prepend(defaultOption);

            topicSelect.addEventListener('change', (e) => {
                loadCategory(e.target.value);
            });

            flipButton.addEventListener('click', flipCard);
            nextButton.addEventListener('click', nextCard);
            prevButton.addEventListener('click', prevCard);

            document.addEventListener('keydown', (e) => {
                if (currentCards.length === 0) return;
                if (e.key === 'ArrowRight') {
                    nextCard();
                } else if (e.key === 'ArrowLeft') {
                    prevCard();
                } else if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    flipCard();
                }
            });

            updateCardContent();
        });
    </script>
</body>

</html>