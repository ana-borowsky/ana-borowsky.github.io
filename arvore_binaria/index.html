<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guia de estudos de Árvores Binárias de Busca</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .node, .line {
            transition: all 0.7s ease-in-out;
        }
        #quiz-container {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        /* Estilos para desabilitar inputs */
        .controls-disabled fieldset {
            opacity: 0.5;
            pointer-events: none;
        }
        /* Estilos das abas */
        .tab-btn {
            border-bottom: 2px solid transparent;
        }
        .tab-btn.active {
            border-color: #4f46e5; /* indigo-600 */
            color: #4f46e5;
        }
        /* Estilos para o conteúdo da teoria */
        #theory-content h2, #quiz-content h2 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-top: 2rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.5rem;
        }
         #theory-content h3 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }
        #theory-content p, #theory-content ul {
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 1rem;
        }
        #theory-content ul {
            list-style-type: disc;
            padding-left: 1.5rem;
        }
        #theory-content code {
            background-color: #f3f4f6;
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            font-family: monospace;
        }
        #theory-content strong {
            font-weight: 600;
        }
        .theory-example-container {
            margin: 1.5rem auto;
            max-width: 450px;
        }
        .theory-svg-wrapper {
            position: relative;
            width: 100%;
            min-height: 220px; /* Define uma altura mínima mas permite que cresça */
            background-color: #f8fafc;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
        }
        .quiz-option {
            display: block;
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            text-align: left;
            transition: all 0.2s;
            cursor: pointer;
        }
        .quiz-option:hover:not(:disabled) {
            border-color: #4f46e5;
            background-color: #eef2ff;
        }
        .quiz-option.correct {
            background-color: #dcfce7;
            border-color: #22c55e;
        }
        .quiz-option.incorrect {
            background-color: #fee2e2;
            border-color: #ef4444;
        }
        .node-highlight circle {
            fill: #facc15; /* yellow-400 */
            stroke: #ca8a04; /* yellow-600 */
            transform: scale(1.1);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-400 via-purple-500 to-pink-500 text-slate-800 flex flex-col items-center min-h-screen p-4">

    <div class="w-full max-w-7xl mx-auto bg-neutral-50 rounded-2xl shadow-lg p-6 md:p-8 mt-4 md:mt-10">
        <header class="mb-6 text-center">
            <h1 class="text-2xl md:text-3xl font-bold text-slate-900">Guia de estudos de Árvores Binárias de Busca</h1>
            <p class="text-slate-600 mt-2">Alterne entre 'Prática', 'Teoria' e 'Quiz' para aprofundar seus conhecimentos.</p>
        </header>

        <!-- Abas de Navegação -->
        <div class="border-b border-slate-200 mb-6">
            <nav class="flex -mb-px space-x-6" aria-label="Tabs">
                <button id="tab-practice" class="tab-btn active whitespace-nowrap py-3 px-1 text-sm font-semibold transition-colors">Prática</button>
                <button id="tab-theory" class="tab-btn whitespace-nowrap py-3 px-1 text-sm font-semibold text-slate-500 hover:text-slate-700 transition-colors">Teoria</button>
                <button id="tab-quiz" class="tab-btn whitespace-nowrap py-3 px-1 text-sm font-semibold text-slate-500 hover:text-slate-700 transition-colors">Quiz</button>
            </nav>
        </div>

        <!-- Conteúdo da Aba de Prática -->
        <div id="practice-content">
            <div class="flex flex-col lg:flex-row gap-8">
                <!-- Coluna de Controles -->
                <div id="controls-section" class="lg:w-1/3">
                    <fieldset id="controls-fieldset">
                         <h2 class="text-xl font-bold text-slate-800 mb-4 text-left">Criar Árvore</h2>
                         <div class="space-y-4">
                             <div class="bg-slate-100 p-4 rounded-lg text-left">
                                 <label for="node-count" class="block text-sm font-medium text-slate-700">Nós aleatórios</label>
                                 <div class="flex items-center gap-2 mt-1">
                                     <input type="number" id="node-count" value="7" min="1" max="10" class="w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                                     <button id="generate-tree-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-4 rounded-md transition-colors">Gerar</button>
                                 </div>
                             </div>
                             <div class="bg-slate-100 p-4 rounded-lg text-left">
                                 <label for="node-value" class="block text-sm font-medium text-slate-700">Inserir / Remover nó</label>
                                 <div class="flex items-center gap-2 mt-1">
                                     <input type="number" id="node-value" placeholder="Valor" class="w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                                     <button id="insert-node-btn" class="w-1/2 bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-4 rounded-md transition-colors">Inserir</button>
                                     <button id="remove-node-btn" class="w-1/2 bg-red-600 hover:bg-red-700 text-white font-medium py-2 px-4 rounded-md transition-colors">Remover</button>
                                 </div>
                                 <button id="replay-btn" class="hidden w-full mt-2 bg-slate-500 hover:bg-slate-600 text-white font-medium py-2 px-4 rounded-md transition-colors">Rever Animação</button>
                             </div>
                              <div class="bg-slate-100 p-4 rounded-lg text-left">
                                 <label for="sequence-input" class="block text-sm font-medium text-slate-700">Construir a partir de lista</label>
                                 <div class="flex flex-wrap items-center gap-2 mt-1">
                                     <input type="text" id="sequence-input" placeholder="Ex: 50, 25, -50" class="w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                                     <button id="build-tree-btn" class="flex-grow bg-purple-600 hover:bg-purple-700 text-white font-medium py-2 px-4 rounded-md transition-colors">Construir</button>
                                      <button id="pause-resume-sequence-btn" class="hidden flex-grow bg-yellow-500 hover:bg-yellow-600 text-white font-medium py-2 px-4 rounded-md transition-colors">Pausar</button>
                                     <button id="replay-sequence-btn" class="hidden flex-grow bg-slate-500 hover:bg-slate-600 text-white font-medium py-2 px-4 rounded-md transition-colors">Replay</button>
                                 </div>
                             </div>
                             <div class="bg-slate-100 p-4 rounded-lg text-left">
                                 <label class="block text-sm font-medium text-slate-700 mb-2">Travessia (Percursos)</label>
                                 <div class="grid grid-cols-1 sm:grid-cols-3 gap-2">
                                     <button id="inorder-btn" class="bg-sky-500 hover:bg-sky-600 text-white font-medium py-2 px-3 rounded-md transition-colors text-sm">Em Ordem</button>
                                     <button id="preorder-btn" class="bg-sky-500 hover:bg-sky-600 text-white font-medium py-2 px-3 rounded-md transition-colors text-sm">Pré-Ordem</button>
                                     <button id="postorder-btn" class="bg-sky-500 hover:bg-sky-600 text-white font-medium py-2 px-3 rounded-md transition-colors text-sm">Pós-Ordem</button>
                                 </div>
                                  <div id="traversal-output" class="mt-3 text-center text-sm font-mono bg-white p-2 rounded h-12 flex items-center justify-center"></div>
                             </div>
                         </div>
                    </fieldset>
                </div>
                <!-- Coluna da Árvore -->
                <div class="lg:w-2/3 flex flex-col">
                    <div id="visualization-container" class="w-full h-96 lg:h-full flex-grow bg-slate-100 rounded-lg flex items-center justify-center overflow-hidden relative">
                        <svg id="tree-svg" width="100%" height="100%"></svg>
                        <p id="empty-message" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-slate-500 text-center w-full px-4">Use os controles para começar.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Conteúdo da Aba de Teoria -->
        <div id="theory-content" class="hidden text-left max-w-4xl mx-auto">
            <h2>O que é uma Árvore Binária de Busca (ABB)?</h2>
            <p>
                Uma <strong>Árvore Binária de Busca</strong> (do inglês, <em>Binary Search Tree</em> ou BST) consiste em um conjunto de nós, onde cada nó possui no máximo dois filhos: um à esquerda e um à direita.
            </p>
            <P>Existem três componentes em uma árvore binária:</P>
            <ul>
                <li>A raiz</li>
                <li>Subárvore esquerda</li>
                <li>Subárvore direita</li>
            </ul>

            <p>Cada subárvore também é uma árvore binária e pode ou não estar vazia.</p>
            <p>Além disso, subárvores esquerda e direita são conjuntos disjuntos de nós.</p>

            <p>A principal característica que define uma ABB é a sua propriedade de ordenação:</p>
            <ul>
                <li>Para qualquer nó <code>N</code>, todos os valores na sua subárvore <strong>esquerda</strong> são <strong>menores</strong> que o valor de <code>N</code>.</li>
                <li>Para qualquer nó <code>N</code>, todos os valores na sua subárvore <strong>direita</strong> são <strong>maiores</strong> que o valor de <code>N</code>.</li>
                <li>Ambas as subárvores (esquerda e direita) também devem ser árvores binárias de busca.</li>
            </ul>

            <div class="theory-example-container">
                <p class="text-center text-sm text-slate-600 mb-2">Exemplo de uma ABB válida:</p>
                <div class="block flex justify-center items-center">
                    <svg id="theory-svg-bst" width="200%" height="200%" class="scale-[1.3]"></svg>
                </div>
            </div>

            <p>Esta propriedade torna operações como busca, inserção e remoção muito eficientes, com uma complexidade de tempo média de <strong>O(log n)</strong>, onde 'n' é o número de nós na árvore.</p>

            <h2>Elementos</h2>
            <ul>
                <li> O elemento da raiz de uma subárvore é chamado nó pai.</li>
                <li>A raiz de sua subárvore esquerda é chamada filho esquerdo e a raiz da subárvore direita é chamado filho direito.</li>
                <li>Um determinado nó que não possui filhos (subárvores esquerda e direita são vazias) é chamado de <strong>nó folha</strong>.</li>
                <li>Dois nós são ditos irmãos se são filhos do mesmo nó-pai.</li>
                <li>A altura de um nó é dada da seguinte forma: a raiz tem altura 0 e a altura de qualquer outro nó é dado pela distância do nó até a raiz da árvore.</li>
                <li>A altura de uma árvore é dada pela maior altura obtida dentre o conjunto de nós folha da árvore.</li>
            </ul>

            <h2>O Pior Cenário: Árvore Desbalanceada</h2>
            <p>
                A eficiência de uma ABB depende de sua altura. Se os nós forem inseridos em uma ordem já ordenada (por exemplo: 10, 20, 30, 40, 50), a árvore pode se tornar <strong>desbalanceada</strong>, assumindo a forma de uma lista ligada.
            </p>
             <div class="theory-example-container">
                <p class="text-center text-sm text-slate-600 mb-2">Exemplo de uma ABB desbalanceada:</p>
                <div class="theory-svg-wrapper"><svg id="theory-svg-unbalanced" width="100%" height="100%"></svg></div>
             </div>
            <p>Neste cenário, a altura da árvore se torna 'n', e a complexidade das operações cai para <strong>O(n)</strong>, o mesmo que uma busca linear em uma lista. Estruturas como as <a href="#" class="text-indigo-600 hover:underline">Árvores AVL</a> ou Rubro-Negras foram criadas para resolver este problema através do auto-balanceamento.</p>
            <p class="text-center text-sm text-slate-600 mb-2">Não são árvores binárias
            <img src="src/assets/images/imagem1.png" class="w-1/2 block mx-auto"><br>

            <h2>Implementação dinâmica</h2>
            <img src="src/assets/images/imagem2.png" class="w-1/3 block mx-auto"><br>
            <img src="src/assets/images/imagem3.png" class="w-1/3 block mx-auto"><br>


            <h2>Travessia (Percursos)</h2>
            <p>Em uma Lista simplesmente encadeada, a única forma de pesquisar seus elementos é percorrer a lista sequencialmente, em ordem linear. Porém, em uma árvore existem várias estratégias de pesquisa. Todas elas envolvem a visita ao nó raiz e às suas subárvores esquerda e direita em uma determinada ordem.</p>
            <p class="text-center text-sm text-slate-600 mb-2">Árvore binária que será usada nas travessias
            <img src="src/assets/images/imagem4.png" class="w-3/4 block mx-auto"><br>
            <p>Existem três formas principais de travessia em profundidade:</p>

            <h3>1. Pré-Ordem (Pre-order)</h3>
            <p>A travessia <strong>Pré-Ordem</strong> segue os passos:
            <ul>
                <li>Visite a raiz da árvore</li>
                <li>Percorra a subárvore esquerda</li>
                <li>Percorra a subárvore direita</li>
            </ul>
            <p>Ou <strong>raiz, esquerda, direita</strong>.</p>
            <p class="text-center bg-slate-100 p-3 rounded-md"><code>Resultado: 8, 5, 3, 6, 11, 10, 14</code></p>
            <p><strong>Dica extra:</strong> desenhe uma bolinha ao <strong>lado esquerdo</strong> de todos os nós, e passe o lápis conforme o tracejado do desenho. Quando o lápis passa numa bolinha, coloque na lista.</p>
            <img src="src/assets/images/imagem5.png" class="w-1/2 block mx-auto"><br>

            <h3>2. Em Ordem (In-order)</h3>
            <p>A travessia <strong>Em Ordem</strong> segue os passos:
            <ul>
                <li>Percorra a subárvore esquerda</li>
                <li>Visite a raiz da árvore</li>
                <li>Percorra a subárvore direita</li>
            </ul>
            <p>Ou <strong>esquerda, raiz, direita</strong>.</p>
            <p class="text-center bg-slate-100 p-3 rounded-md"><code>Resultado: 3, 5, 6, 8, 10, 11, 14</code></p>
            <p><strong>Dica extra:</strong> desenhe uma bolinha <strong>embaixo</strong> de todos os nós, e passe o lápis conforme o tracejado do desenho. Quando o lápis passa numa bolinha, coloque na lista.</p>
            <img src="src/assets/images/imagem6.png" class="w-1/2 block mx-auto"><br>

            <h3>3. Pós-Ordem (Post-order)</h3>
            <p>A travessia <strong>Pós-Ordem</strong> segue os passos:
            <ul>
                <li>Percorra a subárvore esquerda</li>
                <li>Percorra a subárvore direita</li>
                <li>Visite a raiz da árvore</li>
            </ul>
            <p>Ou <strong>esquerda, direita, raiz</strong>.</p>
            <p class="text-center bg-slate-100 p-3 rounded-md"><code>Resultado: 3, 6, 5, 10, 14, 11, 8</code></p>
            <p><strong>Dica extra:</strong> desenhe uma bolinha ao <strong>lado direito</strong> de todos os nós, e passe o lápis conforme o tracejado do desenho. Quando o lápis passa numa bolinha, coloque na lista.</p>
            <img src="src/assets/images/imagem7.png" class="w-1/2 block mx-auto"><br>
            </div>


        <!-- Conteúdo da Aba de Quiz -->
        <div id="quiz-content" class="hidden text-center">
             <div id="quiz-selection-screen">
                <h2>Quiz sobre Árvores Binárias de Busca</h2>
                <p class="my-4">Teste seus conhecimentos. Escolha um dos quizzes abaixo para começar.</p>
                <div id="quiz-buttons-container" class="flex flex-col gap-4 mx-auto max-w-xs">
                    <!-- Buttons will be generated here -->
                </div>
             </div>
             <div id="quiz-container" class="hidden max-w-2xl mx-auto">
                <div id="quiz-progress" class="text-sm text-slate-600 mb-2 text-right"></div>
                <p id="quiz-question" class="text-xl font-semibold mb-4 text-left"></p>
                <div id="quiz-practice-area" class="hidden my-4">
                    <div class="w-full h-64 bg-slate-100 rounded-lg mx-auto max-w-md">
                        <svg id="quiz-tree-svg" width="100%" height="100%"></svg>
                    </div>
                </div>
                <div id="quiz-options" class="space-y-3"></div>
                <div id="quiz-explanation" class="hidden mt-4 p-3 bg-slate-100 rounded-lg text-left text-sm"></div>
                <button id="next-question-btn" class="hidden mt-6 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg">Próxima Pergunta</button>
             </div>
             <div id="quiz-results-screen" class="hidden">
                 <h2>Quiz Finalizado!</h2>
                 <p class="my-4 text-lg">Sua pontuação foi:</p>
                 <p id="quiz-score" class="text-4xl font-bold text-indigo-600"></p>
                 <div class="flex justify-center gap-4 mt-8">
                     <button id="restart-quiz-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 transform hover:scale-105">Tentar Novamente este Quiz</button>
                     <button id="back-to-quizzes-btn" class="bg-slate-500 hover:bg-slate-600 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 transform hover:scale-105">Ver Outros Quizzes</button>
                 </div>
             </div>
        </div>
    </div>

    <script>
        // --- Classes e Variáveis Globais ---
        class Node {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
            }
        }

        // --- DOM Elements ---
        const svg = document.getElementById('tree-svg');
        const emptyMessage = document.getElementById('empty-message');
        const controlsFieldset = document.getElementById('controls-fieldset');
        const generateBtn = document.getElementById('generate-tree-btn');
        const countInput = document.getElementById('node-count');
        const insertBtn = document.getElementById('insert-node-btn');
        const removeBtn = document.getElementById('remove-node-btn');
        const valueInput = document.getElementById('node-value');
        const sequenceInput = document.getElementById('sequence-input');
        const buildTreeBtn = document.getElementById('build-tree-btn');
        const inorderBtn = document.getElementById('inorder-btn');
        const preorderBtn = document.getElementById('preorder-btn');
        const postorderBtn = document.getElementById('postorder-btn');
        const traversalOutput = document.getElementById('traversal-output');
        const replayBtn = document.getElementById('replay-btn');
        const replaySequenceBtn = document.getElementById('replay-sequence-btn');
        const pauseResumeSequenceBtn = document.getElementById('pause-resume-sequence-btn');

        const tabPractice = document.getElementById('tab-practice');
        const tabTheory = document.getElementById('tab-theory');
        const tabQuiz = document.getElementById('tab-quiz');
        const practiceContent = document.getElementById('practice-content');
        const theoryContent = document.getElementById('theory-content');
        const quizContent = document.getElementById('quiz-content');

        // --- Quiz DOM Elements ---
        const quizStartScreen = document.getElementById('quiz-selection-screen');
        const quizButtonsContainer = document.getElementById('quiz-buttons-container');
        const quizContainer = document.getElementById('quiz-container');
        const quizResultsScreen = document.getElementById('quiz-results-screen');
        const restartQuizBtn = document.getElementById('restart-quiz-btn');
        const backToQuizzesBtn = document.getElementById('back-to-quizzes-btn');
        const quizQuestionEl = document.getElementById('quiz-question');
        const quizOptionsEl = document.getElementById('quiz-options');
        const quizPracticeArea = document.getElementById('quiz-practice-area');
        const quizTreeSvg = document.getElementById('quiz-tree-svg');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const quizProgressEl = document.getElementById('quiz-progress');
        const quizScoreEl = document.getElementById('quiz-score');
        const quizExplanationEl = document.getElementById('quiz-explanation');

        // --- State ---
        let root = null;
        let isAnimating = false;
        let lastOperation = null;
        let lastSequence = null;
        let isSequencePaused = false;
        let shuffledQuestions, currentQuestionIndex, score, currentQuizNumber;


        // --- Lógica da Árvore Binária de Busca (ABB) ---
        function insert(node, value) {
            if (!node) {
                return new Node(value);
            }
            if (value < node.value) {
                node.left = insert(node.left, value);
            } else if (value > node.value) {
                node.right = insert(node.right, value);
            }
            return node;
        }

        function removeNode(node, value) {
            if (node === null) {
                return null;
            }
            if (value < node.value) {
                node.left = removeNode(node.left, value);
                return node;
            } else if (value > node.value) {
                node.right = removeNode(node.right, value);
                return node;
            } else {
                if (node.left === null) {
                    return node.right;
                } else if (node.right === null) {
                    return node.left;
                }
                let temp = node.right;
                while (temp.left !== null) {
                    temp = temp.left;
                }
                node.value = temp.value;
                node.right = removeNode(node.right, temp.value);
                return node;
            }
        }

        function findNodeByValue(node, value) {
            if (!node) return null;
            if (node.value === value) return node;
            return value < node.value ? findNodeByValue(node.left, value) : findNodeByValue(node.right, value);
        }

        function countNodes(node) {
            if (!node) return 0;
            return 1 + countNodes(node.left) + countNodes(node.right);
        }

        // --- Lógica de Travessia ---
        function inOrder(node, result = []) {
            if (node) {
                inOrder(node.left, result);
                result.push(node.value);
                inOrder(node.right, result);
            }
            return result;
        }
        function preOrder(node, result = []) {
            if (node) {
                result.push(node.value);
                preOrder(node.left, result);
                preOrder(node.right, result);
            }
            return result;
        }
        function postOrder(node, result = []) {
            if (node) {
                postOrder(node.left, result);
                postOrder(node.right, result);
                result.push(node.value);
            }
            return result;
        }

        // --- Lógica de Visualização ---
        function getPositions(node, x, y, xOffset, map) {
            if (!node) return;
            map.set(node.value, { x, y });
            if (node.left) getPositions(node.left, x - xOffset, y + 80, xOffset / 2, map);
            if (node.right) getPositions(node.right, x + xOffset, y + 80, xOffset / 2, map);
        }

        function drawTree(node, svgEl = svg) {
            svgEl.innerHTML = '';

            if (!node) {
                if (svgEl === svg) emptyMessage.classList.remove('hidden');
                return;
            }
            if (svgEl === svg) emptyMessage.classList.add('hidden');

            const positions = new Map();
            const virtualWidth = 800;
            getPositions(node, virtualWidth / 2, 50, virtualWidth / 4, positions);

            const nodeCount = countNodes(node);
            const MAX_R = 15;
            const MIN_R = 10;
            const START_SHRINK_COUNT = 8;
            const MAX_SHRINK_COUNT = 25;
            let radius = MAX_R;
            if (nodeCount > START_SHRINK_COUNT) {
                const shrinkRange = MAX_SHRINK_COUNT - START_SHRINK_COUNT;
                const nodesOverThreshold = nodeCount - START_SHRINK_COUNT;
                const shrinkProgress = Math.min(1, nodesOverThreshold / shrinkRange);
                radius = MAX_R - (MAX_R - MIN_R) * shrinkProgress;
            }

            if (positions.size > 0) {
                 let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

                 for (const pos of positions.values()) {
                     minX = Math.min(minX, pos.x);
                     maxX = Math.max(maxX, pos.x);
                     minY = Math.min(minY, pos.y);
                     maxY = Math.max(maxY, pos.y);
                 }

                 const treeContentWidth = maxX - minX;
                 const treeContentHeight = maxY - minY;

                 const padding = 50;
                 const desiredViewBoxWidth = treeContentWidth + padding * 2;
                 const desiredViewBoxHeight = treeContentHeight + padding * 2;

                 const MIN_VIEWBOX_WIDTH = 400;
                 const MIN_VIEWBOX_HEIGHT = 300;

                 const finalViewBoxWidth = Math.max(desiredViewBoxWidth, MIN_VIEWBOX_WIDTH);
                 const finalViewBoxHeight = Math.max(desiredViewBoxHeight, MIN_VIEWBOX_HEIGHT);

                 const finalViewBoxX = minX - (finalViewBoxWidth - treeContentWidth) / 2;
                 const finalViewBoxY = minY - (finalViewBoxHeight - treeContentHeight) / 2;

                 svgEl.setAttribute('viewBox', `${finalViewBoxX} ${finalViewBoxY} ${finalViewBoxWidth} ${finalViewBoxHeight}`);
            }

            function drawRecursive(curr) {
                if (!curr) return;
                const pos = positions.get(curr.value);
                if (curr.left) { const childPos = positions.get(curr.left.value); drawLine(svgEl, pos.x, pos.y, childPos.x, childPos.y, `line-to-${curr.left.value}`); drawRecursive(curr.left); }
                if (curr.right) { const childPos = positions.get(curr.right.value); drawLine(svgEl, pos.x, pos.y, childPos.x, childPos.y, `line-to-${curr.right.value}`); drawRecursive(curr.right); }
                drawNode(svgEl, pos.x, pos.y, curr.value, `node-${curr.value}`, radius);
            }
            drawRecursive(node);
        }

        function drawNode(svgEl, cx, cy, value, id, radius = 15) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'node');
            g.id = id;
            g.setAttribute('transform', `translate(${cx}, ${cy})`);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('r', radius);
            circle.setAttribute('class', 'fill-sky-200 stroke-sky-500');
            circle.setAttribute('stroke-width', '2');

            const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            valueText.setAttribute('y', 4);
            valueText.setAttribute('text-anchor', 'middle');
            valueText.setAttribute('class', 'fill-slate-900 font-bold text-sm');
            valueText.textContent = value;

            g.appendChild(circle);
            g.appendChild(valueText);
            svgEl.appendChild(g);
        }

        function drawLine(svgEl, x1, y1, x2, y2, id) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.id = id;
            line.setAttribute('class', 'line stroke-slate-400');
            line.setAttribute('stroke-width', '2');
            svgEl.prepend(line);
        }

        // --- Animações ---
        async function runAnimatedOperation(operation) {
            if (isAnimating) return;
            const val = parseInt(valueInput.value);
            if (isNaN(val)) return;
            if (operation === 'insert' && findNodeByValue(root, val)) return;
            if (operation === 'remove' && !findNodeByValue(root, val)) return;

            const initialState = root ? JSON.parse(JSON.stringify(root)) : null;
            lastOperation = { initialState, val, operation };

            await executeAnimatedOperation(initialState, val, operation);

            replayBtn.classList.remove('hidden');
            valueInput.value = '';
        }

        async function executeAnimatedOperation(initialTreeState, value, operation) {
            if (isAnimating) return;
            isAnimating = true;
            controlsFieldset.disabled = true;
            traversalOutput.textContent = '';

            root = initialTreeState ? JSON.parse(JSON.stringify(initialTreeState)) : null;
            drawTree(root);
            await new Promise(res => setTimeout(res, 200));

            if (operation === 'insert') {
                root = insert(root, value);
                drawTree(root);
                const newNodeEl = svg.querySelector(`#node-${value}`);
                const lineToNewNode = svg.querySelector(`#line-to-${value}`);
                if (newNodeEl) {
                    newNodeEl.style.opacity = '0';
                    if (lineToNewNode) lineToNewNode.style.opacity = '0';
                    await new Promise(res => setTimeout(res, 50));
                    newNodeEl.style.opacity = '1';
                    if (lineToNewNode) lineToNewNode.style.opacity = '1';
                }
                await new Promise(res => setTimeout(res, 750));
            } else { // 'remove'
                if (findNodeByValue(root, value)) {
                    const nodeToRemoveEl = svg.querySelector(`#node-${value}`);
                    if (nodeToRemoveEl) {
                        nodeToRemoveEl.style.opacity = '0';
                        const lineToNode = svg.querySelector(`#line-to-${value}`);
                        if (lineToNode) lineToNode.style.opacity = '0';
                    }
                    await new Promise(res => setTimeout(res, 750));
                    root = removeNode(root, value);
                    drawTree(root);
                }
            }

            isAnimating = false;
            controlsFieldset.disabled = false;
        }

        async function runSequence(operations) {
            isAnimating = true;
            controlsFieldset.disabled = true;
            replaySequenceBtn.classList.add('hidden');
            buildTreeBtn.classList.add('hidden');
            pauseResumeSequenceBtn.classList.remove('hidden');
            pauseResumeSequenceBtn.textContent = 'Pausar';
            isSequencePaused = false;

            root = null;
            drawTree(root);
            await new Promise(res => setTimeout(res, 500));

            for (const num of operations) {
                while (isSequencePaused) {
                    await new Promise(res => setTimeout(res, 100));
                }

                if (num >= 0) { // Inserção
                    if (!findNodeByValue(root, num)) {
                        root = insert(root, num);
                        drawTree(root);
                        const newNodeEl = svg.querySelector(`#node-${num}`);
                        const lineToNewNode = svg.querySelector(`#line-to-${num}`);
                        if (newNodeEl) {
                            newNodeEl.style.opacity = '0';
                            if(lineToNewNode) lineToNewNode.style.opacity = '0';
                            await new Promise(res => setTimeout(res, 50));
                            newNodeEl.style.opacity = '1';
                            if(lineToNewNode) lineToNewNode.style.opacity = '1';
                        }
                    }
                } else { // Remoção
                    const valToRemove = Math.abs(num);
                    if (findNodeByValue(root, valToRemove)) {
                        const nodeToRemoveEl = svg.querySelector(`#node-${valToRemove}`);
                        if(nodeToRemoveEl) nodeToRemoveEl.style.opacity = '0';
                        const lineToNode = svg.querySelector(`#line-to-${valToRemove}`);
                        if(lineToNode) lineToNode.style.opacity = '0';
                        await new Promise(res => setTimeout(res, 750));
                        root = removeNode(root, valToRemove);
                        drawTree(root);
                    }
                }
                await new Promise(res => setTimeout(res, 800));
            }

            pauseResumeSequenceBtn.classList.add('hidden');
            buildTreeBtn.classList.remove('hidden');
            if (lastSequence && lastSequence.length > 0) {
                replaySequenceBtn.classList.remove('hidden');
            }
            isAnimating = false;
            controlsFieldset.disabled = false;
        }

        async function animateTraversal(order) {
            if (isAnimating || !root) return;
            isAnimating = true;
            controlsFieldset.disabled = true;
            traversalOutput.textContent = '';

            document.querySelectorAll('.node-highlight').forEach(el => el.classList.remove('node-highlight'));

            const delay = 500;
            let outputText = [];

            for (const val of order) {
                const nodeEl = document.getElementById(`node-${val}`);
                if (nodeEl) {
                    nodeEl.classList.add('node-highlight');
                    outputText.push(val);
                    traversalOutput.textContent = outputText.join(', ');
                    await new Promise(res => setTimeout(res, delay));
                    nodeEl.classList.remove('node-highlight');
                }
            }

            isAnimating = false;
            controlsFieldset.disabled = false;
        }


        // --- Lógica Geral e de Abas ---
        function switchTab(tabId) {
            [practiceContent, theoryContent, quizContent].forEach(c => c.classList.add('hidden'));
            [tabPractice, tabTheory, tabQuiz].forEach(t => t.classList.remove('active'));

            document.getElementById(tabId).classList.remove('hidden');
            document.querySelector(`[id=tab-${tabId.split('-')[0]}]`).classList.add('active');

            if (tabId === 'practice-content') {
                drawTree(root);
            }
            if (tabId === 'quiz-content') {
                 quizContainer.classList.add('hidden');
                 quizResultsScreen.classList.add('hidden');
                 quizStartScreen.classList.remove('hidden');
            }
        }

        // --- Lógica da Teoria ---
        function initializeTheoryExamples() {
             const svgBst = document.getElementById('theory-svg-bst');
             let bstRoot = null;
             [8, 5, 11, 3, 6, 10, 14].forEach(val => bstRoot = insert(bstRoot, val));
             drawTree(bstRoot, svgBst);

             const svgUnbalanced = document.getElementById('theory-svg-unbalanced');
             let unbalancedRoot = null;
             [10, 20, 30, 40, 50].forEach(val => unbalancedRoot = insert(unbalancedRoot, val));
             drawTree(unbalancedRoot, svgUnbalanced);
        }

        // --- Lógica do QUIZ ---
        const quizQuestions = [
            // Quiz 1: Conceitos Básicos
            { type: 'theory', question: 'Em uma ABB, onde estaria um nó com valor 15 em relação a um nó raiz com valor 20?', options: ['Na subárvore esquerda', 'Na subárvore direita', 'Pode estar em qualquer uma', 'Não pode ser inserido'], correctAnswer: 'Na subárvore esquerda', explanation: 'Valores menores que a raiz são sempre inseridos na subárvore esquerda.' },
            { type: 'theory', question: 'Qual travessia em uma ABB resulta nos valores em ordem crescente?', options: ['Pré-Ordem', 'Pós-Ordem', 'Em Ordem', 'Em Nível'], correctAnswer: 'Em Ordem', explanation: 'A travessia Em Ordem (Esquerda, Raiz, Direita) visita os nós de uma ABB em ordem ascendente.' },
            { type: 'theory', question: 'Qual é a complexidade de tempo do pior caso para uma busca em uma ABB?', options: ['O(1)', 'O(log n)', 'O(n)', 'O(n^2)'], correctAnswer: 'O(n)', explanation: 'No pior caso, a ABB fica desbalanceada, parecendo uma lista ligada, e a busca se torna linear.' },
            { type: 'theory', question: 'Dada a sequência de inserção [10, 20, 5], qual nó será a raiz da árvore?', options: ['10', '20', '5', 'Qualquer um'], correctAnswer: '10', explanation: 'O primeiro elemento inserido em uma ABB sempre se torna a raiz.' },
            { type: 'theory', question: 'Na travessia Pré-Ordem, qual nó é visitado primeiro?', options: ['O menor nó (folha mais à esquerda)', 'A raiz', 'O maior nó (folha mais à direita)', 'O nó do meio'], correctAnswer: 'A raiz', explanation: 'A sequência da Pré-Ordem é Raiz, Esquerda, Direita.' },
            { type: 'theory', question: 'Se deletar um nó com dois filhos, qual nó irá substituí-lo?', options: ['Seu filho esquerdo', 'Seu filho direito', 'Seu sucessor em ordem (o menor da subárvore direita)', 'A raiz da árvore'], correctAnswer: 'Seu sucessor em ordem (o menor da subárvore direita)', explanation: 'Substituir pelo sucessor em ordem (ou predecessor) mantém a propriedade da ABB.' },

            // Quiz 2: Percursos Práticos
            { type: 'practice', question: 'Qual o resultado da travessia EM ORDEM para a árvore abaixo?', values: [50, 30, 70, 20, 40, 60, 80], correctAnswer: '20, 30, 40, 50, 60, 70, 80'},
            { type: 'practice', question: 'Qual o resultado da travessia PRÉ-ORDEM para a árvore abaixo?', values: [50, 30, 70, 20, 40, 60, 80], correctAnswer: '50, 30, 20, 40, 70, 60, 80'},
            { type: 'practice', question: 'Qual o resultado da travessia PÓS-ORDEM para a árvore abaixo?', values: [50, 30, 70, 20, 40, 60, 80], correctAnswer: '20, 40, 30, 60, 80, 70, 50'},
            { type: 'practice', question: 'Qual o resultado da travessia EM ORDEM para a árvore abaixo?', values: [10, 20, 30, 5], correctAnswer: '5, 10, 20, 30'},
            { type: 'practice', question: 'Qual o resultado da travessia PRÉ-ORDEM para a árvore abaixo?', values: [45, 22, 77, 11, 30, 90, 15], correctAnswer: '45, 22, 11, 15, 30, 77, 90'},
            { type: 'practice', question: 'Qual o resultado da travessia PÓS-ORDEM para a árvore abaixo?', values: [45, 22, 77, 11, 30, 90, 15], correctAnswer: '15, 11, 30, 22, 90, 77, 45'},

            // Quiz 3: Inserção e Remoção
            { type: 'theory', question: 'O que acontece ao tentar inserir um valor que já existe em uma ABB?', options: ['O nó é inserido à esquerda', 'O nó é inserido à direita', 'A árvore ignora a inserção', 'Um erro é gerado'], correctAnswer: 'A árvore ignora a inserção', explanation: 'ABBs padrão não permitem valores duplicados, então a operação de inserção é simplesmente ignorada.' },
            { type: 'theory', question: 'Como é removido um nó que possui apenas um filho (à direita)?', options: ['O nó é simplesmente apagado', 'O filho direito substitui o nó removido', 'O avô do nó o adota', 'A raiz da árvore o substitui'], correctAnswer: 'O filho direito substitui o nó removido', explanation: 'Se um nó tem apenas um filho, esse filho "sobe" e ocupa a posição do pai.' },
            { type: 'theory', question: 'Qual é o caso mais simples de remoção em uma ABB?', options: ['Remover a raiz', 'Remover um nó com dois filhos', 'Remover um nó folha', 'Remover o maior elemento'], correctAnswer: 'Remover um nó folha', explanation: 'Remover um nó folha (sem filhos) não exige nenhuma reestruturação da árvore; ele é simplesmente desconectado de seu pai.' },
            { type: 'practice', question: 'Após inserir o valor 35 na árvore abaixo, qual será o percurso Em Ordem?', values: [50, 30, 70, 20, 40, 60, 80], correctAnswer: '20, 30, 35, 40, 50, 60, 70, 80'},
            { type: 'practice', question: 'Após remover o valor 70 da árvore abaixo, qual será o percurso Pré-Ordem?', values: [50, 30, 70, 20, 40, 60, 80], correctAnswer: '50, 30, 20, 40, 80, 60'},
            { type: 'practice', question: 'Qual nó substitui a raiz (50) se ela for removida da árvore abaixo?', values: [50, 30, 70, 20, 40, 60, 80], correctAnswer: '60'},

            // Quiz 4: Propriedades e Complexidade
            { type: 'theory', question: 'Qual é a altura mínima de uma ABB com 7 nós?', options: ['1', '2', '3', '4'], correctAnswer: '2', explanation: 'Uma árvore perfeitamente balanceada com 7 nós tem altura 2 (raiz no nível 0, filhos no 1, netos no 2).' },
            { type: 'theory', question: 'Uma árvore onde cada nó tem 0 ou 2 filhos é chamada de:', options: ['Árvore Completa', 'Árvore Cheia', 'Árvore Perfeita', 'Árvore Degenerada'], correctAnswer: 'Árvore Cheia', explanation: 'Uma árvore binária cheia (Full Binary Tree) é aquela em que todo nó tem zero ou dois filhos.' },
            { type: 'theory', question: 'Em uma ABB, o nó com o menor valor é sempre encontrado...', options: ['Na raiz', 'Na folha mais à direita', 'Na folha mais à esquerda', 'Em qualquer lugar'], correctAnswer: 'Na folha mais à esquerda', explanation: 'Seguindo a propriedade da ABB, você sempre vai para a esquerda para encontrar valores menores.' },
            { type: 'practice', question: 'Qual é a altura da árvore abaixo? (A raiz tem altura 0)', values: [50, 30, 70, 20, 40, 80, 10], correctAnswer: '3'},
            { type: 'practice', question: 'Quantos nós folha (nós sem filhos) existem na árvore abaixo?', values: [50, 30, 70, 20, 40, 60, 80], correctAnswer: '4'},
            { type: 'practice', question: 'Qual é o maior valor na subárvore esquerda da raiz na árvore abaixo?', values: [50, 30, 70, 20, 40, 60, 80], correctAnswer: '40'},

            // Quiz 5: Cenários Avançados
            { type: 'theory', question: 'Para encontrar o 3º menor elemento em uma ABB, qual seria a abordagem mais eficiente?', options: ['Fazer uma travessia Pré-Ordem e pegar o 3º', 'Fazer uma travessia Em Ordem e pegar o 3º', 'Fazer uma travessia Pós-Ordem e pegar o 3º', 'Verificar o 3º nível da árvore'], correctAnswer: 'Fazer uma travessia Em Ordem e pegar o 3º', explanation: 'A travessia Em Ordem visita os nós em ordem crescente, então o k-ésimo elemento da travessia é o k-ésimo menor elemento.' },
            { type: 'theory', question: 'O sucessor em ordem de um nó N é:', options: ['O nó visitado imediatamente antes de N em Pré-Ordem', 'O nó pai de N', 'O menor nó na subárvore direita de N', 'O maior nó na subárvore esquerda de N'], correctAnswer: 'O menor nó na subárvore direita de N', explanation: 'O sucessor é o próximo nó que seria visitado na travessia Em Ordem, que é o "menor dos maiores".' },
            { type: 'theory', question: 'O predecessor em ordem de um nó N é:', options: ['O filho esquerdo de N', 'O nó visitado após N em Pós-Ordem', 'O maior nó na subárvore esquerda de N', 'O menor nó da árvore inteira'], correctAnswer: 'O maior nó na subárvore esquerda de N', explanation: 'O predecessor é o nó anterior na travessia Em Ordem, que é o "maior dos menores".' },
            { type: 'practice', question: 'Na árvore abaixo, qual é o sucessor em ordem do nó 30?', values: [50, 30, 70, 20, 40, 60, 80], correctAnswer: '40'},
            { type: 'practice', question: 'Na árvore abaixo, qual é o predecessor em ordem do nó 50?', values: [50, 30, 70, 20, 40, 60, 80], correctAnswer: '40'},
            { type: 'practice', question: 'Qual sequência de inserção criaria uma árvore perfeitamente balanceada?', options: ['10, 20, 30, 40, 50, 60, 70', '40, 20, 60, 10, 30, 50, 70', '70, 60, 50, 40, 30, 20, 10', '10, 70, 20, 60, 30, 50, 40'], correctAnswer: '40, 20, 60, 10, 30, 50, 70', explanation: 'Inserir a mediana primeiro e depois as medianas de cada sub-intervalo tende a criar árvores mais balanceadas.' },
        ];

        function setupQuizSelection() {
            quizButtonsContainer.innerHTML = '';
            const questionsPerQuiz = 6;
            const numQuizzes = Math.ceil(quizQuestions.length / questionsPerQuiz);

            for (let i = 1; i <= numQuizzes; i++) {
                const button = document.createElement('button');
                button.textContent = `Quiz ${i}`;
                button.className = 'bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 transform hover:scale-105';
                button.onclick = () => startQuiz(i);
                quizButtonsContainer.appendChild(button);
            }
        }

        function startQuiz(quizNum) {
            currentQuizNumber = quizNum;
            quizStartScreen.classList.add('hidden');
            quizResultsScreen.classList.add('hidden');
            quizContainer.classList.remove('hidden');

            const questionsPerQuiz = 6;
            const startIndex = (quizNum - 1) * questionsPerQuiz;
            const endIndex = startIndex + questionsPerQuiz;
            const questionSubset = quizQuestions.slice(startIndex, endIndex);

            shuffledQuestions = questionSubset.sort(() => Math.random() - 0.5);
            currentQuestionIndex = 0;
            score = 0;
            displayNextQuestion();
        }

        function displayNextQuestion() {
            resetQuizState();
            if (currentQuestionIndex >= shuffledQuestions.length) {
                showQuizResults();
                return;
            }
            quizProgressEl.textContent = `Pergunta ${currentQuestionIndex + 1} de ${shuffledQuestions.length}`;
            const questionData = shuffledQuestions[currentQuestionIndex];
            quizQuestionEl.textContent = questionData.question;

            if (questionData.type === 'theory') {
                quizPracticeArea.classList.add('hidden');
                questionData.options.forEach(optionText => {
                    const button = document.createElement('button');
                    button.textContent = optionText;
                    button.className = 'quiz-option';
                    button.onclick = () => selectAnswer(button, optionText, questionData.correctAnswer);
                    quizOptionsEl.appendChild(button);
                });
            } else if (questionData.type === 'practice') {
                 quizPracticeArea.classList.remove('hidden');
                 let practiceRoot = null;
                 questionData.values.forEach(val => practiceRoot = insert(practiceRoot, val));

                 requestAnimationFrame(() => {
                     drawTree(practiceRoot, quizTreeSvg);
                 });

                 const correctAnswerText = questionData.correctAnswer.toString();
                 const traversals = [
                     inOrder(practiceRoot).join(', '),
                     preOrder(practiceRoot).join(', '),
                     postOrder(practiceRoot).join(', ')
                 ];

                 let options = [correctAnswerText];
                 traversals.forEach(t => {
                     if (t !== correctAnswerText) {
                         options.push(t);
                     }
                 });

                 // Gera opções aleatórias se não houver o suficiente
                 while(options.length < 4) {
                    const randomTraversal = traversals[Math.floor(Math.random()*traversals.length)].split(', ').sort(() => 0.5 - Math.random()).join(', ');
                    if(!options.includes(randomTraversal)) {
                        options.push(randomTraversal);
                    }
                 }

                 const uniqueOptions = [...new Set(options)];
                 const shuffledOptions = uniqueOptions.sort(() => Math.random() - 0.5).slice(0, 4);
                 if (!shuffledOptions.includes(correctAnswerText)) {
                     shuffledOptions.pop();
                     shuffledOptions.push(correctAnswerText);
                     shuffledOptions.sort(() => Math.random() - 0.5);
                 }


                 shuffledOptions.forEach(optionText => {
                    const button = document.createElement('button');
                    button.textContent = optionText;
                    button.className = 'quiz-option font-mono text-sm';
                    button.onclick = () => selectAnswer(button, optionText, correctAnswerText);
                    quizOptionsEl.appendChild(button);
                 });
            }
        }

        function selectAnswer(buttonEl, selectedAnswer, correctAnswer) {
            const allOptions = quizOptionsEl.querySelectorAll('.quiz-option');
            allOptions.forEach(btn => {
                btn.disabled = true;
                if (btn.textContent === correctAnswer) {
                    btn.classList.add('correct');
                }
            });

            if (selectedAnswer === correctAnswer) {
                score++;
            } else {
                buttonEl.classList.add('incorrect');
            }

            const questionData = shuffledQuestions[currentQuestionIndex];
            if (questionData.explanation) {
                quizExplanationEl.innerHTML = `<strong>Explicação:</strong> ${questionData.explanation}`;
                quizExplanationEl.classList.remove('hidden');
            }

            nextQuestionBtn.classList.remove('hidden');
        }

        function resetQuizState() {
            quizOptionsEl.innerHTML = '';
            quizExplanationEl.classList.add('hidden');
            nextQuestionBtn.classList.add('hidden');
        }

        function showQuizResults() {
            quizContainer.classList.add('hidden');
            quizResultsScreen.classList.remove('hidden');
            quizScoreEl.textContent = `${score} / ${shuffledQuestions.length}`;
        }

        // --- Event Listeners ---
        tabPractice.addEventListener('click', () => switchTab('practice-content'));
        tabTheory.addEventListener('click', () => switchTab('theory-content'));
        tabQuiz.addEventListener('click', () => switchTab('quiz-content'));

        // --- Sandbox Listeners ---
        insertBtn.addEventListener('click', () => runAnimatedOperation('insert'));
        removeBtn.addEventListener('click', () => runAnimatedOperation('remove'));
        replayBtn.addEventListener('click', async () => {
            if (lastOperation) {
                await executeAnimatedOperation(lastOperation.initialState, lastOperation.val, lastOperation.operation);
            }
        });

        generateBtn.addEventListener('click', () => {
            if (isAnimating) return;
            root = null;
            lastOperation = null;
            lastSequence = null;
            replayBtn.classList.add('hidden');
            replaySequenceBtn.classList.add('hidden');
            const count = parseInt(countInput.value) || 7;
            const values = new Set();
            while (values.size < count) {
                values.add(Math.floor(Math.random() * 100));
            }
            values.forEach(val => { root = insert(root, val); });
            drawTree(root);
            traversalOutput.textContent = '';
        });

        buildTreeBtn.addEventListener('click', () => {
             if (isAnimating) return;
             const sequenceText = sequenceInput.value;
             if (!sequenceText) return;
             lastSequence = sequenceText.split(',')
                 .map(s => s.trim()).filter(s => s !== '')
                 .map(s => parseInt(s, 10)).filter(n => !isNaN(n));

             runSequence(lastSequence);
        });

        replaySequenceBtn.addEventListener('click', () => {
             if (lastSequence) runSequence(lastSequence);
        });

        pauseResumeSequenceBtn.addEventListener('click', () => {
             isSequencePaused = !isSequencePaused;
             pauseResumeSequenceBtn.textContent = isSequencePaused ? 'Continuar' : 'Pausar';
        });

        sequenceInput.addEventListener('input', () => {
            replaySequenceBtn.classList.add('hidden');
            lastSequence = null;
        });

        // --- Traversal Listeners ---
        inorderBtn.addEventListener('click', () => animateTraversal(inOrder(root)));
        preorderBtn.addEventListener('click', () => animateTraversal(preOrder(root)));
        postorderBtn.addEventListener('click', () => animateTraversal(postOrder(root)));

        // --- Quiz Listeners ---
        nextQuestionBtn.addEventListener('click', () => {
            currentQuestionIndex++;
            displayNextQuestion();
        });
        restartQuizBtn.addEventListener('click', () => startQuiz(currentQuizNumber));
        backToQuizzesBtn.addEventListener('click', () => {
             quizResultsScreen.classList.add('hidden');
             quizStartScreen.classList.remove('hidden');
        });

        // --- Inicialização ---
        window.addEventListener('resize', () => {
            if (!practiceContent.classList.contains('hidden')) {
                drawTree(root);
            }
        });

        switchTab('practice-content');
        initializeTheoryExamples();
        setupQuizSelection();
        generateBtn.click();

    </script>
</body>
</html>

