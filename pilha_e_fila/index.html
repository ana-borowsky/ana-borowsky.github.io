<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guia de estudos de Filas e Pilhas</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .theory-example-container {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        #theory-content h2 {
            font-size: 1.5rem; font-weight: 700; margin-top: 2rem; margin-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb; padding-bottom: 0.5rem;
        }
        #theory-content h3 { font-size: 1.25rem; font-weight: 600; margin-top: 1.5rem; margin-bottom: 0.75rem; }
        #theory-content p, #theory-content ul { font-size: 1rem; line-height: 1.6; margin-bottom: 1rem; }
        #theory-content ul { list-style-type: disc; padding-left: 1.5rem; }
        #theory-content code { background-color: #f3f4f6; padding: 0.2rem 0.4rem; border-radius: 0.25rem; font-family: monospace; }
        #theory-content strong { font-weight: 600; }

        /* Estilos para anima√ß√µes da teoria */
        .theory-example-container {
            margin: 1.5rem auto;
            max-width: 450px;
        }
        .theory-svg-wrapper {
            position: relative;
            width: 100%;
            height: 220px;
            background-color: #f8fafc;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            overflow: hidden;
        }
        .theory-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 0.75rem;
        }
        .theory-btn {
            background-color: #4338ca; color: white; padding: 0.5rem 1rem; border-radius: 0.375rem;
            font-weight: 500; transition: background-color 0.2s;
        }
        .theory-btn:hover { background-color: #3730a3; }
        .theory-svg-wrapper svg g { transition: all 0.6s ease-in-out; }

        #stack-theory-wrapper { height: 280px; }

        /* Fallback para imagens quebradas */
        img {
            display: block;
            position: relative;
            background-color: #f3f4f6;
            border-radius: 0.5rem;
            text-align: center;
            color: #6b7280;
            padding: 1rem;
        }
        img::after {
            content: 'Imagem n√£o encontrada';
            font-size: 0.875rem;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-400 via-purple-500 to-pink-500 text-slate-800 flex flex-col items-center min-h-screen p-4">

    <div class="w-full max-w-5xl mx-auto bg-neutral-50 rounded-2xl shadow-lg p-6 md:p-8 mt-6">
        <header class="mb-6 text-center">
            <h1 class="text-2xl md:text-3xl font-bold text-slate-900">Guia de estudos de Filas e Pilhas</h1>
            <p class="text-slate-600 mt-2">Explore os conceitos de Filas e Pilhas com anima√ß√µes interativas.</p>
        </header>

        <!-- Conte√∫do da Aba de Teoria -->
        <div id="theory-content">
             <h2>O que √© uma Pilha (Stack)? ü•û</h2>
             <p>Uma pilha √© uma cole√ß√£o ordenada de √≠tens na qual os itens podem ser inseridos e retirados a partir da √∫ltima posi√ß√£o, chamada topo da pilha. Ou seja, ela segue o princ√≠pio <strong>LIFO (Last-In, First-Out)</strong>, que significa "o √∫ltimo a entrar √© o primeiro a sair".</p>
             <p>A melhor analogia √© uma <strong>pilha de pratos</strong>. Voc√™ coloca um prato no topo da pilha e, quando precisa de um, retira o prato que est√° no topo. N√£o √© poss√≠vel retirar um prato do meio ou da base sem antes remover todos os que est√£o acima dele.</p>
             <div class="theory-example-container">
                <div class="theory-svg-wrapper" id="stack-theory-wrapper"><svg id="theory-svg-stack"></svg></div>
                <div class="theory-controls">
                    <button id="play-stack" class="theory-btn">Play</button>
                    <button id="replay-stack" class="theory-btn">Replay</button>
                </div>
            </div>
             <h3>Opera√ß√µes Principais</h3>
             <ul>
                <li><code>insere():</code> insere um novo elemento na pilha</li>
                <li><code>cheia():</code> Verifica se a pilha est√° cheia</li>
                <li><code>vazia():</code> Verifica se a pilha est√° vazia</li>
                <li><code>remove():</code> Remove um elemento da pilha</li>
                <li><code>imprime():</code> Imprime todos os elementos da pilha.</li>
             </ul>

             <h3>Implementa√ß√£o com vetor</h3>
            <img src="src/assets/images/imagem1.png" class="w-1/2 block mx-auto">
            <p>Inicialmente o √≠ndice topo √© inicializado com ‚Äì1. Isto indica que a pilha est√° vazia. Desta forma pode-se implementar um teste para verificar se a pilha est√° vazia da seguinte forma:</p>
            <img src="src/assets/images/imagem2.png" class="w-1/2 block mx-auto">
            <p>Obs: Pode-se retornar o valor do topo no caso de n√£o vazia.</p>
            <p>√â importante verificar a realiza√ß√£o do teste de ‚Äúoverflow‚Äù antes de efetivamente inserir o elemento na pilha. Este teste pode ser implementado da seguinte forma:</p>
            <img src="src/assets/images/imagem3.png" class="w-1/2 block mx-auto"><br>

            <p class="text-center text-sm text-slate-600 mb-2">Inser√ß√£o / Empilhamento</p>
            <img src="src/assets/images/imagem4.png" class="w-1/2 block mx-auto"><br>

            <p class="text-center text-sm text-slate-600 mb-2">Remo√ß√£o / Desempilhamento
            <img src="src/assets/images/imagem5.png" class="w-1/2 block mx-auto"><br>


            <h2 class="mt-12">O que √© uma Fila? üö∂‚Äç‚ôÇÔ∏èüö∂‚Äç‚ôÄÔ∏èüö∂</h2>
            <p>Uma Fila √© uma estrutura de dados linear que segue o princ√≠pio <strong>FIFO (First-In, First-Out)</strong>, que significa "o primeiro a entrar √© o primeiro a sair".</p>
            <p>Pense numa <strong>fila de supermercado</strong>. A primeira pessoa que chega √† fila √© a primeira a ser atendida e a sair. Novas pessoas chegam (<code>enqueue</code>) no <strong>fim</strong> da fila, e as pessoas s√£o atendidas (<code>dequeue</code>) no <strong>in√≠cio</strong> da fila.</p>
            <div class="theory-example-container">
                <div class="theory-svg-wrapper"><svg id="theory-svg-queue"></svg></div>
                <div class="theory-controls">
                    <button id="play-queue" class="theory-btn">Play</button>
                    <button id="replay-queue" class="theory-btn">Replay</button>
                </div>
            </div>
            <h3>Opera√ß√µes Principais</h3>
            <ul>
                <li><code>cheia():</code> verifica se a fila est√° cheia</li>
                <li><code>vazia():</code> verifica se a fila est√° vazia</li>
                <li><code>insere(E):</code> insere o elemento E na Fila;</li>
                <li><code>remove():</code> remove um elemento da Fila.</li>
                <li><code>imprime():</code> imprime todos os elementos da Fila, do primeiro ao √∫ltimo </li>
            </ul>
            <p>Assim como nas pilhas, as opera√ß√µes b√°sicas de uma fila tamb√©m t√™m complexidade de tempo de <strong>O(1)</strong>.</p>
            <h3>Implementa√ß√£o com vetor</h3>
            <img src="src/assets/images/imagem8.png" class="w-1/2"><br>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- L√≥gica de Anima√ß√£o da Teoria ---
        const SVG_NS = "http://www.w3.org/2000/svg";

        function createTheoryItem(id, value, x, y) {
            const g = document.createElementNS(SVG_NS, 'g');
            g.setAttribute('id', id);
            g.setAttribute('transform', `translate(${x}, ${y})`);
            g.style.opacity = '0';

            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.setAttribute('width', '50');
            rect.setAttribute('height', '50');
            rect.setAttribute('rx', '6');
            rect.setAttribute('class', 'fill-indigo-200 stroke-indigo-500');
            rect.setAttribute('stroke-width', '2');

            const text = document.createElementNS(SVG_NS, 'text');
            text.setAttribute('x', '25');
            text.setAttribute('y', '30');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('class', 'fill-slate-900 font-bold');
            text.textContent = value;

            g.appendChild(rect);
            g.appendChild(text);
            return g;
        }

        function createTheoryPointer(id, textContent, x, y) {
            const g = document.createElementNS(SVG_NS, 'g');
            g.setAttribute('id', id);
            g.setAttribute('transform', `translate(${x}, ${y})`);
            g.style.opacity = '0';

            const text = document.createElementNS(SVG_NS, 'text');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('class', 'font-semibold text-slate-600');
            text.textContent = textContent;

            g.appendChild(text);
            return g;
        }

        function setupTheoryAnimation(svgId, playId, replayId, animationFunc, initialStateFunc) {
            const svg = document.getElementById(svgId);
            const playBtn = document.getElementById(playId);
            const replayBtn = document.getElementById(replayId);
            let isTheoryAnimating = false;

            const reset = () => {
                isTheoryAnimating = false;
                svg.innerHTML = '';
                initialStateFunc(svg);
                playBtn.disabled = false;
            }

            playBtn.addEventListener('click', async () => {
                if (isTheoryAnimating) return;
                isTheoryAnimating = true;
                playBtn.disabled = true;
                await animationFunc(svg);
                isTheoryAnimating = false;
            });
            replayBtn.addEventListener('click', reset);

            reset();
        }

        // Anima√ß√£o da Pilha
        const drawInitialStack = (svg) => {
            svg.setAttribute('viewBox', '0 0 450 280');
            const border = document.createElementNS(SVG_NS, 'path');
            border.setAttribute('d', 'M 175 270 L 175 40 L 275 40 L 275 270');
            border.setAttribute('class', 'stroke-slate-300 stroke-2 fill-none');
            svg.appendChild(border);
        };

        async function animateStackTheory(svg) {
            const wait = (ms) => new Promise(res => setTimeout(res, ms));
            const centerX = 225;
            const itemHeight = 55; // height + gap
            const startY = 210;

            // Step 1: Push 10
            const item10 = createTheoryItem('t-stack-10', '10', centerX - 25, 10);
            const pointer = createTheoryPointer('t-stack-ptr', 'Topo', centerX, startY - 5);
            svg.appendChild(item10);
            svg.appendChild(pointer);
            await wait(100);
            item10.style.opacity = '1';
            item10.setAttribute('transform', `translate(${centerX - 25}, ${startY})`);
            pointer.style.opacity = '1';
            await wait(800);

            // Step 2: Push 20
            const item20 = createTheoryItem('t-stack-20', '20', centerX - 25, 10);
            svg.appendChild(item20);
            await wait(100);
            item20.style.opacity = '1';
            item20.setAttribute('transform', `translate(${centerX - 25}, ${startY - itemHeight})`);
            pointer.setAttribute('transform', `translate(${centerX}, ${startY - itemHeight - 5})`);
            await wait(800);

            // Step 3: Push 30
            const item30 = createTheoryItem('t-stack-30', '30', centerX - 25, 10);
            svg.appendChild(item30);
            await wait(100);
            item30.style.opacity = '1';
            item30.setAttribute('transform', `translate(${centerX - 25}, ${startY - itemHeight * 2})`);
            pointer.setAttribute('transform', `translate(${centerX}, ${startY - itemHeight * 2 - 5})`);
            await wait(800);

            // Step 4: Push 40
            const item40 = createTheoryItem('t-stack-40', '40', centerX - 25, 10);
            svg.appendChild(item40);
            await wait(100);
            item40.style.opacity = '1';
            item40.setAttribute('transform', `translate(${centerX - 25}, ${startY - itemHeight * 3})`);
            pointer.setAttribute('transform', `translate(${centerX}, ${startY - itemHeight * 3 - 5})`);
            await wait(1200);

            // Step 5: Pop 40
            item40.setAttribute('transform', `translate(${centerX - 25}, -50)`);
            item40.style.opacity = '0';
            pointer.setAttribute('transform', `translate(${centerX}, ${startY - itemHeight * 2 - 5})`);
            await wait(800);

            // Step 6: Pop 30
            item30.setAttribute('transform', `translate(${centerX - 25}, -50)`);
            item30.style.opacity = '0';
            pointer.setAttribute('transform', `translate(${centerX}, ${startY - itemHeight - 5})`);
            await wait(800);
        }

        // Anima√ß√£o da Fila
        const drawInitialQueue = (svg) => {
             svg.setAttribute('viewBox', '0 0 450 220');
        };

        async function animateQueueTheory(svg) {
            const wait = (ms) => new Promise(res => setTimeout(res, ms));
            const startX = 20;
            const itemGap = 60;
            const y = 80;

            // Step 1: Enqueue A
            const itemA = createTheoryItem('t-queue-A', 'A', 400, y);
            const ptrFront = createTheoryPointer('t-queue-front', 'In√≠cio', startX + 25, y + 85);
            const ptrRear = createTheoryPointer('t-queue-rear', 'Fim', startX + 25, y + 85);
            svg.appendChild(itemA);
            svg.appendChild(ptrFront);
            svg.appendChild(ptrRear);
            await wait(100);
            itemA.style.opacity = '1';
            itemA.setAttribute('transform', `translate(${startX}, ${y})`);
            ptrFront.style.opacity = '1';
            ptrRear.style.opacity = '1';
            await wait(800);

            // Step 2: Enqueue B
            const itemB = createTheoryItem('t-queue-B', 'B', 400, y);
            svg.appendChild(itemB);
            await wait(100);
            itemB.style.opacity = '1';
            itemB.setAttribute('transform', `translate(${startX + itemGap}, ${y})`);
            ptrRear.setAttribute('transform', `translate(${startX + itemGap + 25}, ${y + 85})`);
            await wait(800);

            // Step 3: Enqueue C
            const itemC = createTheoryItem('t-queue-C', 'C', 400, y);
            svg.appendChild(itemC);
            await wait(100);
            itemC.style.opacity = '1';
            itemC.setAttribute('transform', `translate(${startX + itemGap * 2}, ${y})`);
            ptrRear.setAttribute('transform', `translate(${startX + itemGap * 2 + 25}, ${y + 85})`);
            await wait(800);

            // Step 4: Enqueue D
            const itemD = createTheoryItem('t-queue-D', 'D', 400, y);
            svg.appendChild(itemD);
            await wait(100);
            itemD.style.opacity = '1';
            itemD.setAttribute('transform', `translate(${startX + itemGap * 3}, ${y})`);
            ptrRear.setAttribute('transform', `translate(${startX + itemGap * 3 + 25}, ${y + 85})`);
            await wait(1200);

            // Step 5: Dequeue A
            itemA.setAttribute('transform', `translate(-60, ${y})`);
            itemA.style.opacity = '0';
            ptrFront.setAttribute('transform', `translate(${startX + itemGap + 25}, ${y + 85})`);
            await wait(800);

            // Step 6: Dequeue B
            itemB.setAttribute('transform', `translate(-60, ${y})`);
            itemB.style.opacity = '0';
            ptrFront.setAttribute('transform', `translate(${startX + itemGap * 2 + 25}, ${y + 85})`);
            await wait(800);
        }

        // --- Inicializa√ß√£o ---
        setupTheoryAnimation('theory-svg-stack', 'play-stack', 'replay-stack', animateStackTheory, drawInitialStack);
        setupTheoryAnimation('theory-svg-queue', 'play-queue', 'replay-queue', animateQueueTheory, drawInitialQueue);
    });
    </script>
</body>
</html>

