<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algoritmos de Ordenação</title>
  <!-- Incluindo o Tailwind CSS para estilização -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Incluindo a fonte Roboto Mono do Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    /* Aplicando a fonte Roboto Mono como padrão */
    body {
      font-family: 'Roboto Mono', monospace;
    }

    #tab-content {
      /* box-shadow: Removido */
    }

    /* Estilo customizado para o botão ativo (será sobrescrito pelo JS) */
    .tab-button.active {
      border-bottom-color: transparent !important;
      z-index: 10;
    }
  </style>
</head>

<body
  class="bg-gradient-to-br from-blue-400 via-purple-500 to-pink-500 min-h-screen flex items-center justify-center p-4">

  <!-- Card principal que centraliza o conteúdo -->
  <main class="bg-white rounded-2xl shadow-2xl p-4 md:p-8 max-w-7xl w-full text-center transform transition-all">

    <!-- Título principal -->
    <h1 class="text-3xl md:text-4xl font-light text-gray-800 mb-6">
      Algoritmos de Ordenação
    </h1>

    <!-- Navegação por Abas -->
    <div class="border-b-2 border-gray-200">
      <div id="tab-nav" class="flex flex-nowrap justify-start md:justify-around -mb-0.5">
        <button data-tab="bubbleSort" class="tab-button" aria-controls="bubbleSort-content">Bubble Sort</button>
        <button data-tab="quickSort" class="tab-button" aria-controls="quickSort-content">Quick Sort</button>
        <button data-tab="cocktailSort" class="tab-button" aria-controls="cocktailSort-content">Cocktail Sort</button>
        <button data-tab="selectionSort" class="tab-button" aria-controls="selectionSort-content">Selection
          Sort</button>
        <button data-tab="insertionSort" class="tab-button" aria-controls="insertionSort-content">Insertion
          Sort</button>
        <button data-tab="mergeSort" class="tab-button" aria-controls="mergeSort-content">Merge Sort</button>
        <button data-tab="combSort" class="tab-button" aria-controls="combSort-content">Comb Sort</button>
        <button data-tab="gnomeSort" class="tab-button" aria-controls="gnomeSort-content">Gnome Sort</button>
        <button data-tab="bucketSort" class="tab-button" aria-controls="bucketSort-content">Bucket Sort</button>
        <button data-tab="quiz" class="tab-button" aria-controls="quiz-content">Quiz</button>
      </div>
    </div>

    <!-- Conteúdo das Abas -->
    <div id="tab-content" class="text-left p-6 md:p-8 bg-white rounded-b-2xl rounded-tr-2xl">
      <!-- 1. Bubble Sort -->
      <div data-tab-content="bubbleSort" class="tab-content" id="bubbleSort-content">
        <h2 class="text-2xl font-bold text-purple-600 mb-4">1. Bubble Sort (Ordenação por Bolha)</h2>
        <!-- Placeholder GIF INSERIDO AQUI -->
        <img src="src/assets/images/bubblesort.gif" alt="Animação GIF do algoritmo Quick Sort"
          class="max-w-lg mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <!-- FIM Placeholder GIF -->
        <p class="mb-4 text-gray-700">
          O Bubble Sort é o mais simples e conhecido algoritmo de ordenação. Ele percorre repetidamente a lista. Em
          cada passo, todo elemento i é comparado com o
          seu sucessor i + 1. Se o sucessor é menor do que
          i então os elementos são trocados. O conjunto de dados é percorrido n-1 vezes. O nome "bolha" 
          vem do fato de que os elementos maiores "flutuam" para o
          topo (fim) da lista a cada passagem. É considerado ineficiente para grandes conjuntos de dados.  
        </p>
        <h3 class="text-xl font-semibold text-gray-800 mb-2">Complexidade:</h3>
        <ul class="list-disc list-inside ml-4 text-gray-600">
          <li>Pior Caso: O(n²)</li>
          <li>Caso Médio: O(n²)</li>
          <li>Melhor Caso: O(n) (quando a lista já está ordenada e há uma otimização de parada)</li>
        </ul>
        <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">Uso:</h3>
        <p class="text-gray-600">Principalmente para fins educacionais ou para listas muito pequenas.</p>
      
      <br><h3 class="text-xl font-semibold text-gray-800 mb-2">Código:</h3>
      <img src="src/assets/images/bubblesort_codigo.png" 
        class="w-3/4 mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
      <br><h3 class="text-xl font-semibold text-gray-800 mb-2">Exemplo:</h3>
      <img src="src/assets/images/bubblesort1.png"
        class="max-w-lg mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
      <br>
      <h3 class="text-xl font-semibold text-gray-800 mb-2">Atividade:</h3>
      <p class="text-gray-600">Melhore o desempenho do bubblesort implementado
      analisando critérios de parada.</p>
      <ul class="list-disc list-inside ml-4 text-gray-600">
        <li>Conte o número de trocas do original e da nova
        implementação e imprima ao final.</li>
        <li>Conte o numero de iterações e imprima ao final.</li>
      </ul><br>
      <div class="flex justify-center items-center flex-col">
      <a href="https://visualgo.net/en/sorting" target="_blank" rel="noopener noreferrer"
        class="w-1/2 text-center block bg-purple-500 text-white font-light py-4 px-6 rounded-xl shadow-lg transform transition-transform hover:scale-105 hover:bg-purple-600 focus:outline-none focus:ring-4 focus:ring-sky-300">
        Site para visualizar algoritmos de ordenação
      </a><br>
      <a href="https://www.youtube.com/watch?v=xli_FI7CuzA" target="_blank" rel="noopener noreferrer"
        class=" w-1/2 block bg-blue-500 text-white text-center font-light py-4 px-6 rounded-xl shadow-lg transform transition-transform hover:scale-105 hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-sky-300">
        Vídeo Bubble Sort
      </a><br>      
      </div>
      </div>
      <!-- 2. Quick Sort -->
      <div data-tab-content="quickSort" class="tab-content hidden" id="quickSort-content">
        <h2 class="text-2xl font-bold text-purple-600 mb-4">2. Quick Sort (Ordenação Rápida)</h2>
        <!-- Placeholder GIF INSERIDO AQUI -->
        <img src="src/assets/images/quicksort.gif"
          alt="Animação GIF do algoritmo Quick Sort"
          class="max-w-lg mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <!-- FIM Placeholder GIF -->
        <p class="mb-4 text-gray-700">
          O Quicksort é um dos algoritmos
          de ordenação mais eficientes para
          listas grandes e desordenadas.
          Usa o conceito de “dividir para
          conquistar”. Ele funciona escolhendo um elemento
          como 'pivô' e particionando o array em torno desse pivô. Os elementos menores que o pivô são colocados à sua
          esquerda, e os maiores à sua direita, e chama a si
          mesmo recursivamente para
          ordenar as subpartes.
        </p>

        <h3 class="text-xl font-semibold text-gray-800 mb-2">Complexidade:</h3>
        <ul class="list-disc list-inside ml-4 text-gray-600">
          <li>Pior Caso: O(n²) (ocorre com pivôs ruins, como escolher sempre o menor ou maior elemento)</li>
          <li>Caso Médio: O(nlog n)</li>
          <li>Melhor Caso: O(nlog n)</li>
        </ul>
        <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">Uso:</h3>
        <p class="text-gray-600">Um dos algoritmos de ordenação mais rápidos e mais usados na prática. É preferido para
          arrays na memória principal.</p>
        <img src="src/assets/images/quicksort1.png" alt="Animação GIF do algoritmo Quick Sort"
          class="max-w-lg mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
      
      <br>
      <h3 class="text-xl font-semibold text-gray-800 mb-2">Passo a passo:</h3>
      <p class="text-gray-600">
        O quicksort escolhe um pivô (geralmente o primeiro elemento,
        mas pode ser qualquer elemento).
      </p>
      <ul class="list-disc list-inside ml-4 text-gray-600">
        <li>Reorganiza o vetor: todos menores que o pivô vão para a esquerda
          e todos maiores para a direita.</li>
        <li>O pivô é colocado em sua posição correta.</li>
        <li>O algoritmo é chamado recursivamente para a parte à esquerda
          do pivô e a parte à direita, até dividir o vetor todo.
        </li>
      </ul>
      <br>
      <h3 class="text-xl font-semibold text-gray-800 mb-2">Código:</h3>
      <img src="src/assets/images/quicksort_codigo.png"
        class="w-3/4 mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
      <img src="src/assets/images/quicksort_codigo2.png"
        class="w-full mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md"><br>
        <br>
      <h3 class="text-xl font-semibold text-gray-800 mb-2">Atividade:</h3>
      <ul class="list-disc list-inside ml-4 text-gray-600">
        <li>Tente rodar “na mão” a seguinte sequência: {3,2,8,1,5}</li>
        <li>Qual a saída na terceira rodada?</li>
      </ul><br>
      
      <div class="flex justify-center items-center flex-col">
        <a href="https://visualgo.net/en/sorting" target="_blank" rel="noopener noreferrer"
          class="w-1/2 text-center block bg-purple-500 text-white font-light py-4 px-6 rounded-xl shadow-lg transform transition-transform hover:scale-105 hover:bg-purple-600 focus:outline-none focus:ring-4 focus:ring-sky-300">
          Site para visualizar algoritmos de ordenação
        </a><br>
        <a href="https://www.youtube.com/watch?v=MZaf_9IZCrc" target="_blank" rel="noopener noreferrer"
          class=" w-1/2 block bg-blue-500 text-white text-center font-light py-4 px-6 rounded-xl shadow-lg transform transition-transform hover:scale-105 hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-sky-300">
          Vídeo Quicksort Sort
        </a><br>
      </div>
      </div>

      <!-- 3. Cocktail Sort -->
      <div data-tab-content="cocktailSort" class="tab-content hidden" id="cocktailSort-content">
        <h2 class="text-2xl font-bold text-purple-600 mb-4">3. Cocktail Sort</h2>
        <!-- Placeholder GIF INSERIDO AQUI -->
        <img src="src/assets/images/cocktailsort.gif" alt="Animação GIF do algoritmo Quick Sort"
          class="max-w-lg mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <!-- FIM Placeholder GIF -->
        <p class="mb-4 text-gray-700">
          É uma variação do Bubble Sort. Ele melhora a
          eficiência do Bubble Sort ao ordenar em ambas as direções (frente e verso) em cada passagem. Isso permite que
          os elementos pequenos no final da lista se movam mais rapidamente para o início.
        </p>
        <h3 class="text-xl font-semibold text-gray-800 mb-2">Complexidade:</h3>
        <ul class="list-disc list-inside ml-4 text-gray-600">
          <li>Pior Caso: O(n²)</li>
          <li>Caso Médio: O(n²)</li>
          <li>Melhor Caso: O(n) (quando a lista já está quase ordenada)</li>
        </ul><br>
        <p class="mb-4 text-gray-700">Melhor desempenho para certos casos:</p>
        <ul class="list-disc list-inside ml-4 text-gray-600">
          <li>O Cocktail Sort pode ser mais rápido quando a maioria dos
          elementos já está no lugar e há apenas um pequeno número de
          elementos "fora de lugar" no final da lista. A passada bidirecional
          ajuda a mover esses elementos rapidamente para suas posições
          finais.</li>
        </ul><br>
        <p class="mb-4 text-gray-700">Mais eficiente na movimentação de elementos:</p>
        <ul class="list-disc list-inside ml-4 text-gray-600">
          <li>Por mover para frente e para trás, o Cocktail Sort é mais rápido
          para trazer elementos que estão no final da lista para o início e
          vice-versa</li>
        </ul>
        <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">Uso:</h3>
        <p class="text-gray-600">Raramente usado na prática, mas pode ser ligeiramente mais rápido que o Bubble Sort em
          listas onde os elementos estão "presos" nas extremidades opostas.</p>
        <br>
        <h3 class="text-xl font-semibold text-gray-800 mb-2">Código:</h3>
        <img src="src/assets/images/cocktailsort_codigo.png"
          class="w-full mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <br>
        <br>
        <div class="flex justify-center items-center flex-col">
          <a href="https://visualgo.net/en/sorting" target="_blank" rel="noopener noreferrer"
            class="w-1/2 text-center block bg-purple-500 text-white font-light py-4 px-6 rounded-xl shadow-lg transform transition-transform hover:scale-105 hover:bg-purple-600 focus:outline-none focus:ring-4 focus:ring-sky-300">
            Site para visualizar algoritmos de ordenação
          </a><br>
          <a href="https://www.youtube.com/watch?v=gz8BIiVZdg0" target="_blank" rel="noopener noreferrer"
            class=" w-1/2 block bg-blue-500 text-white text-center font-light py-4 px-6 rounded-xl shadow-lg transform transition-transform hover:scale-105 hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-sky-300">
            Vídeo Cocktail Sort
          </a><br>
        </div>
      </div>

      <!-- 4. Selection Sort -->
      <div data-tab-content="selectionSort" class="tab-content hidden" id="selectionSort-content">
        <h2 class="text-2xl font-bold text-purple-600 mb-4">4. Selection Sort (Ordenação por Seleção)</h2>
        <!-- Placeholder GIF INSERIDO AQUI -->
        <img src="src/assets/images/selectionsort.gif" alt="Animação GIF do algoritmo Quick Sort"
          class="max-w-lg mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <!-- FIM Placeholder GIF -->
        <p class="mb-4 text-gray-700">
          O Selection Sort divide a lista em duas sublistas: a ordenada (à esquerda, inicialmente vazia) e a não
          ordenada (à direita, com todos os elementos). O algoritmo encontra o menor elemento na sublista não ordenada e
          o troca com o primeiro elemento da sublista não ordenada.
        </p>
        <h3 class="text-xl font-semibold text-gray-800 mb-2">Complexidade:</h3>
        <ul class="list-disc list-inside ml-4 text-gray-600">
          <li>Pior Caso: O(n²)</li>
          <li>Caso Médio: O(n²)</li>
          <li>Melhor Caso: O(n²)</li>
        </ul>
        <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">Uso:</h3>
        <p class="text-gray-600">Não é eficiente para grandes listas, mas é útil em situações onde a escrita (trocas) na
          memória é custosa, pois ele minimiza o número de trocas (apenas uma troca por iteração completa).</p>
        <br><h3 class="text-xl font-semibold text-gray-800 mb-2">Código:</h3>
        <img src="src/assets/images/selectionsort_codigo.png"
          class="w-3/4 mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <br>
        <h3 class="text-xl font-semibold text-gray-800 mb-2">Atividade:</h3>
        <p>Compare com o algoritmo anterior e verifique quem faz mais
        trocas e quantas iterações foram necessárias.</p>
        <br>
        <div class="flex justify-center items-center flex-col">
          <a href="https://visualgo.net/en/sorting" target="_blank" rel="noopener noreferrer"
            class="w-1/2 text-center block bg-purple-500 text-white font-light py-4 px-6 rounded-xl shadow-lg transform transition-transform hover:scale-105 hover:bg-purple-600 focus:outline-none focus:ring-4 focus:ring-sky-300">
            Site para visualizar algoritmos de ordenação
          </a><br>
          <a href="https://www.youtube.com/watch?v=g-PGLbMth_g" target="_blank" rel="noopener noreferrer"
            class=" w-1/2 block bg-blue-500 text-white text-center font-light py-4 px-6 rounded-xl shadow-lg transform transition-transform hover:scale-105 hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-sky-300">
            Vídeo Selection Sort
          </a><br>
        </div>
      </div>      

      <!-- 5. Insertion Sort -->
      <div data-tab-content="insertionSort" class="tab-content hidden" id="insertionSort-content">
        <h2 class="text-2xl font-bold text-purple-600 mb-4">5. Insertion Sort (Ordenação por Inserção)</h2>
        <!-- Placeholder GIF INSERIDO AQUI -->
        <img src="src/assets/images/insertionsort.gif" alt="Animação GIF do algoritmo Quick Sort"
          class="max-w-lg mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <!-- FIM Placeholder GIF -->
        <p class="mb-4 text-gray-700">
          O Insertion Sort constrói a lista final ordenada um item de cada vez. Ele itera sobre os elementos de entrada
          e insere cada um em sua posição correta dentro da sublista que já está ordenada, deslocando os elementos
          maiores para a direita.
        </p>
        <h3 class="text-xl font-semibold text-gray-800 mb-2">Complexidade:</h3>
        <ul class="list-disc list-inside ml-4 text-gray-600">
          <li>Pior Caso: O(n²)</li>
          <li>Caso Médio: O(n²)</li>
          <li>Melhor Caso: O(n) (quando a lista já está ordenada)</li>
        </ul><br>
        <p class="text-gray-600">
          O insertion sort geralmente é considerado melhor do que o
          bubble sort e o selection sort para a maioria dos cenários
          simples, especialmente vetores pequenos ou quase ordenados.
        </p><br>
        <p class="text-gray-600">
          Desempenho prático: Embora os três algoritmos tenham
          desempenhos teóricos parecidos ,o insertion sort é mais rápido
          na prática, pois realiza menos movimentações e comparações,
          especialmente se o vetor já está quase ordenado.
        </p><br>
        <p class="text-gray-600">
          O melhor caso do insertion sort é quando o vetor já está
          ordenado, enquanto bubble e selection continuam realizando
          várias comparações mesmo neste cenário.
        </p><br>
        <p class="text-gray-600">
          Movimentação de dados: O selection sort faz o menor número de
          trocas, mas mais comparações; já o bubble sort faz muitas
          trocas, sendo geralmente o mais lento.
        </p><br>
        <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">Uso:</h3>
        <p class="text-gray-600">Extremamente eficiente para listas pequenas e para listas que já estão quase ordenadas.
          É comumente usado como parte de outros algoritmos mais avançados (como o TimSort, que combina Merge Sort e
          Insertion Sort).</p>
        <img src="src/assets/images/insertionsort_codigo.png"
          class="w-3/4 mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <br>   
        <div class="flex justify-center items-center flex-col">
          <a href="https://visualgo.net/en/sorting" target="_blank" rel="noopener noreferrer"
            class="w-1/2 text-center block bg-purple-500 text-white font-light py-4 px-6 rounded-xl shadow-lg transform transition-transform hover:scale-105 hover:bg-purple-600 focus:outline-none focus:ring-4 focus:ring-sky-300">
            Site para visualizar algoritmos de ordenação
          </a><br>
          <a href="https://www.youtube.com/watch?v=JU767SDMDvA" target="_blank" rel="noopener noreferrer"
            class=" w-1/2 block bg-blue-500 text-white text-center font-light py-4 px-6 rounded-xl shadow-lg transform transition-transform hover:scale-105 hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-sky-300">
            Vídeo Insertion Sort
          </a><br>
        </div>

      </div>

      <!-- 6. Merge Sort -->
      <div data-tab-content="mergeSort" class="tab-content hidden" id="mergeSort-content">
        <h2 class="text-2xl font-bold text-purple-600 mb-4">6. Merge Sort (Não cai na prova)</h2>
        <img src="src/assets/images/em_obras.png"
          class="max-w-lg mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <!-- Placeholder GIF INSERIDO AQUI -->
        <img src="src/assets/images/mergesort.gif" alt="Animação GIF do algoritmo Quick Sort"
          class="max-w-lg mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <!-- FIM Placeholder GIF -->
        <p class="mb-4 text-gray-700">
          O Merge Sort é um algoritmo de divisão e conquista que garante uma complexidade $O(n \log n)$ em todos os
          casos. Ele divide o array recursivamente em metades até que cada sublista contenha apenas um elemento (que é,
          por definição, ordenado). Em seguida, ele mescla as sublistas de volta de forma ordenada.
        </p>
        <h3 class="text-xl font-semibold text-gray-800 mb-2">Complexidade:</h3>
        <ul class="list-disc list-inside ml-4 text-gray-600">
          <li>Pior Caso: $O(n \log n)$</li>
          <li>Caso Médio: $O(n \log n)$</li>
          <li>Melhor Caso: $O(n \log n)$</li>
        </ul>
        <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">Uso:</h3>
        <p class="text-gray-600">Garante desempenho consistente em qualquer cenário. É usado para ordenar listas
          encadeadas de forma eficiente e é um dos principais algoritmos de ordenação externa.</p>
      </div>

      <!-- 7. Comb Sort -->
      <div data-tab-content="combSort" class="tab-content hidden" id="combSort-content">
        <h2 class="text-2xl font-bold text-purple-600 mb-4">7. Comb Sort (Ordenação Pente)</h2>
        <!-- Placeholder GIF INSERIDO AQUI -->
        <img src="src/assets/images/em_obras.png"
          class="max-w-lg mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <img src="src/assets/images/combsort.gif" alt="Animação GIF do algoritmo Quick Sort"
          class="max-w-lg mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <!-- FIM Placeholder GIF -->
        <p class="mb-4 text-gray-700">
          O Comb Sort é um algoritmo de comparação que melhora o Bubble Sort eliminando os valores pequenos perto do fim
          da lista (as "tartarugas"). Ele faz isso usando um 'gap' (intervalo) maior do que 1 entre os elementos
          comparados. O gap é reduzido por um fator (geralmente 1.3) a cada iteração até se tornar 1.
        </p>
        <h3 class="text-xl font-semibold text-gray-800 mb-2">Complexidade:</h3>
        <ul class="list-disc list-inside ml-4 text-gray-600">
          <li>Pior Caso: $O(n^2)$</li>
          <li>Caso Médio: $O(n \log n)$ (rápido na prática)</li>
          <li>Melhor Caso: $O(n \log n)$</li>
        </ul>
        <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">Uso:</h3>
        <p class="text-gray-600">Pode ser considerado um substituto mais eficiente para o Bubble Sort e é frequentemente
          usado em conjunto com o Quick Sort para ordenar pequenas partições.</p>
      </div>

      <!-- 8. Gnome Sort -->
      <div data-tab-content="gnomeSort" class="tab-content hidden" id="gnomeSort-content">
        <h2 class="text-2xl font-bold text-purple-600 mb-4">8. Gnome Sort (Ordenação Gnomo)</h2>
        <!-- Placeholder GIF INSERIDO AQUI -->
        <img src="src/assets/images/em_obras.png"
          class="max-w-lg mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <img src="src/assets/images/gnomesort.gif" alt="Animação GIF do algoritmo Quick Sort"
          class="max-w-lg mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <!-- FIM Placeholder GIF -->
        <p class="mb-4 text-gray-700">
          O Gnome Sort é um algoritmo simples de comparação, semelhante ao Insertion Sort, mas que evita loops aninhados
          explícitos. Ele funciona garantindo que o par de elementos adjacentes na posição atual esteja em ordem. Se não
          estiver, ele os troca e recua para verificar a ordem anterior; se estiver, ele avança.
        </p>
        <h3 class="text-xl font-semibold text-gray-800 mb-2">Complexidade:</h3>
        <ul class="list-disc list-inside ml-4 text-gray-600">
          <li>Pior Caso: $O(n^2)$</li>
          <li>Caso Médio: $O(n^2)$</li>
          <li>Melhor Caso: $O(n)$ (quando a lista já está ordenada)</li>
        </ul>
        <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">Uso:</h3>
        <p class="text-gray-600">Principalmente valorizado por ser muito fácil de implementar (tem a linha de código
          mais curta de todos os $O(n^2)$ quadráticos) e por sua estabilidade.</p>
      </div>

      <!-- 9. Bucket Sort -->
      <div data-tab-content="bucketSort" class="tab-content hidden" id="bucketSort-content">
        <h2 class="text-2xl font-bold text-purple-600 mb-4">9. Bucket Sort (Ordenação por Balde)</h2>
        <img src="src/assets/images/em_obras.png"
          class="max-w-lg mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <!-- Placeholder GIF INSERIDO AQUI -->
        <img src="https://placehold.co/600x300/1e293b/f8fafc?text=Bucket+Sort+GIF"
          alt="Animação GIF do algoritmo Bucket Sort"
          class="w-full max-w-lg mx-auto my-6 rounded-lg border border-gray-300 object-cover shadow-md">
        <!-- FIM Placeholder GIF -->
        <p class="mb-4 text-gray-700">
          O Bucket Sort, ou Ordenação por Balde, é um algoritmo de ordenação não-comparativa. Ele divide o array de
          entrada em um número finito de "baldes" (buckets). Cada balde é então ordenado individualmente (geralmente
          usando Insertion Sort) e, por fim, todos os baldes são concatenados para formar o resultado ordenado.
        </p>
        <h3 class="text-xl font-semibold text-gray-800 mb-2">Complexidade:</h3>
        <ul class="list-disc list-inside ml-4 text-gray-600">
          <li>Pior Caso: $O(n^2)$ (se a distribuição for muito desigual)</li>
          <li>Caso Médio: $O(n + k)$ (onde k é o número de baldes, idealmente próximo de n)</li>
          <li>Melhor Caso: $O(n + k)$</li>
        </ul>
        <h3 class="text-xl font-semibold text-gray-800 mt-4 mb-2">Uso:</h3>
        <p class="text-gray-600">Mais eficaz para arrays onde os elementos de entrada estão uniformemente distribuídos
          em um intervalo. É comum em processamento de dados onde a distribuição dos valores é conhecida.</p>
      </div>

      <!-- 10. Quiz -->
      <div data-tab-content="quiz" class="tab-content hidden" id="quiz-content">
        <h2 class="text-2xl font-bold text-orange-600 mb-4">10. Quiz de Ordenação</h2>

        <div id="quiz-container">
          <!-- As perguntas do quiz serão injetadas aqui pelo JS -->
        </div>

        <div class="mt-6">
          <button id="submit-quiz"
            class="bg-orange-500 text-white font-light py-3 px-6 rounded-xl shadow-lg transform transition-transform hover:scale-105 hover:bg-orange-600 focus:outline-none focus:ring-4 focus:ring-orange-300">
            Verificar Respostas
          </button>
        </div>

        <div id="quiz-result" class="mt-6 p-4 rounded-lg text-lg font-semibold hidden">
          <!-- O resultado do quiz será exibido aqui -->
        </div>

      </div>
    </div>

  </main>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabContents = document.querySelectorAll('.tab-content');
      const quizContainer = document.getElementById('quiz-container');
      const submitQuizButton = document.getElementById('submit-quiz');
      const quizResult = document.getElementById('quiz-result');

      // Classes base para os estilos de aba
      const INACTIVE_CLASSES = 'text-gray-600 py-3 px-4 transition-colors border-transparent border-b-2 hover:text-purple-700 hover:border-purple-300 whitespace-nowrap cursor-pointer text-sm font-light';
      const ALGORITHM_ACTIVE_CLASSES = 'text-purple-700 font-semibold border-b-2 border-purple-600 bg-white rounded-t-lg shadow-t-lg -mt-1 pt-4 pb-3 px-4';
      const QUIZ_ACTIVE_CLASSES = 'text-orange-700 font-semibold border-b-2 border-orange-600 bg-white rounded-t-lg shadow-t-lg -mt-1 pt-4 pb-3 px-4';

      function activateTab(tabName) {
        // 1. Desativar todos os botões e conteúdos
        tabButtons.forEach(button => {
          // Reseta para as classes inativas base
          button.className = 'tab-button ' + INACTIVE_CLASSES;
        });
        tabContents.forEach(content => {
          content.classList.add('hidden');
        });

        // 2. Ativar o botão e conteúdo corretos
        const activeButton = document.querySelector(`[data-tab="${tabName}"]`);
        const activeContent = document.querySelector(`[data-tab-content="${tabName}"]`);

        if (activeButton) {
          activeButton.classList.add('active');
          // Aplica estilos ativos
          if (tabName === 'quiz') {
            // Remove classes de hover padrão de algoritmo e adiciona as de quiz
            activeButton.classList.remove('hover:text-purple-700', 'hover:border-purple-300');
            activeButton.classList.add('hover:text-orange-700', 'hover:border-orange-300');
            activeButton.className = 'tab-button active ' + QUIZ_ACTIVE_CLASSES;
          } else {
            activeButton.className = 'tab-button active ' + ALGORITHM_ACTIVE_CLASSES;
          }
        }

        // 3. Exibir conteúdo
        if (activeContent) {
          activeContent.classList.remove('hidden');
        }
      }

      // Inicialização dos estilos de aba
      tabButtons.forEach(button => {
        button.className = 'tab-button ' + INACTIVE_CLASSES;
        button.addEventListener('click', (e) => {
          const tabName = e.currentTarget.getAttribute('data-tab');
          activateTab(tabName);
        });
      });

      // Ativar a aba padrão (Bubble Sort) ao carregar
      activateTab('bubbleSort');

      const quizQuestions = [
        {
          question: "O que não influência a performance de um algoritmo de ordenação?",
          options: ["O tipo de dado armazenado na memória","A estratégia", "O tipo da entrada de dados", "A implementação", "O tamanho da entrada", "A disposição da entrada(Desordenado, parcialmente ordenado, ordenado decrescente)", "Os recursos computacionais"],
          answer: "O tipo da entrada de dados"
        },
        {
          question: "Qual dessas alternativas é o calcanhar de Aquiles do Bubble Sort?",
          options: ["Números pequenos no final do array", "Números grandes no final do array", "Quando a lista de entrada é aleatória"],
          answer: "Números pequenos no final do array"
        },
        {
          question: "Qual algoritmo de ordenação é mais eficiente para listas *quase* ordenadas?",
          options: ["Selection Sort", "Insertion Sort", "Cocktail Sort", "Quick Sort"],
          answer: "Insertion Sort"
        },
        {
          question: "Qual algoritmo de ordenação é uma variação do Bubble Sort que usa um 'gap' para acelerar a movimentação de elementos 'presos'?",
          options: ["Gnome Sort", "Comb Sort", "Selection Sort", "Bucket Sort"],
          answer: "Comb Sort"
        },
        {
          question: "É possível implementar o Insertion Sort recursivo?",
          options: ["Sim", "Não"],
          answer: "Sim"
        },
        {
          question: "É possível implementar o QuickSort de maneira sequencial?",
          options: ["Sim", "Não"],
          answer: "Sim"
        },
        {
          question: "Inicialmente, tem-se o vetor [23,12,4,21]. Após a primeira iteração de um determinado algoritmo de ordenação, o vetor é [12,4,21,23]. Qual foi o algoritmo de ordenação utilizado?",
          options: ["Quick Sort", "Cocktail Sort", "Bubble Sort", "Insertion Sort", "Selection Sort"],
          answer: "Bubble Sort"
        },
        {
          question: "Qual dessas alternativas é o 'calcanhar de Aquiles' do Insertion Sort?",
          options: [
            "Quando a lista de entrada é pequena (menos de 10 elementos)",
            "Quando o array está em ordem decrescente (invertida)",
            "Quando o pivô é sempre o maior ou menor elemento",
            "Quando a lista possui muitos valores iguais"
          ],
          answer: "Quando o array está em ordem decrescente (invertida)"
        },
        {
          question: "Qual algoritmo é uma variação do bubble sort, mas melhora a performance ao ordenar em ambas as direções?",
          options: ["Comb Sort", "Insertion Sort", "Merge Sort", "Cocktail Sort","Selection Sort"],
          answer: "Cocktail Sort"
        },
        {
          question: "Qual é o pior caso para o bubble sort?",
          options: ["Quando a entrada já está ordenada", "Quando a entrada é ordenada ao contrário", "Quando a entrada é aleatória", "Nenhuma das anteriores"],
          answer: "Quando a entrada é ordenada ao contrário"
        },

        {
          question: "Qual dessas alternativas é o 'calcanhar de Aquiles' do Quick Sort?",
          options: [
            "Quando o array contém muitos valores duplicados, forçando a instabilidade",
            "Quando a lista de entrada é totalmente ordenada ou ordenada em ordem inversa",
            "Quando a lista é dividida consistentemente em duas metades quase iguais",
            "O alto consumo de memória para manter a pilha de chamadas recursivas",
            "Nenhuma das anteriores"
          ],
          answer: "Quando a lista de entrada é totalmente ordenada ou ordenada em ordem inversa"
        },
        {
          question: "Dado o vetor [53, 31, 4, 1, 29], após a primeira passagem completa (ida e volta) do algoritmo, o resultado foi [1, 31, 4, 29, 53]. Qual é o algoritmo utilizado?",
          options: ["Bubble Sort", "Cocktail Sort", "Insertion Sort", "Selection Sort", "Quick Sort"],
          answer: "Cocktail Sort"
        },
        {
          question: "Dentre os algoritmos de ordenação por comparação listados abaixo, qual alternativa apresenta a ordem CORRETA de desempenho, do melhor para o pior, considerando a complexidade de tempo assintótica no caso médio?",
          options: [
            "Selection Sort, Insertion Sort, Quick Sort, Bubble Sort",
            "Quick Sort, Insertion Sort, Selection Sort, Bubble Sort",
            "Bubble Sort, Quick Sort, Insertion Sort, Selection Sort",
            "Quick Sort, Insertion Sort, Bubble Sort, Selection Sort"
          ],
          answer: "Quick Sort, Insertion Sort, Selection Sort, Bubble Sort"
        },
        {
          question: "No algoritmo de ordenação, o segundo elemento de [8, 4, 6, 10] é inserido na posição correta em relação ao primeiro, resultando em [4, 8, 6, 10]. Qual foi o algoritmo utilizado?",
          options: ["Insertion Sort", "Selection Sort", "Bubble Sort", "Quick Sort", "Comb Sort"],
          answer: "Insertion Sort"
        },
        {
          question: "O que caracteriza o Gnome Sort?",
          options: [
            "Baseia-se em partições e pivôs",
            "Usa lacunas (gaps) para movimentar elementos",
            "Compara elementos adjacentes e 'retrocede' quando necessário",
            "Divide a lista em baldes (buckets)"
          ],
          answer: "Compara elementos adjacentes e 'retrocede' quando necessário"
        },
        {
          question: "O que significa dizer que um algoritmo de ordenação é 'estável'?",
          options: [
            "Ele mantém a posição relativa de elementos iguais",
            "Ele usa menos memória auxiliar",
            "Ele sempre tem complexidade O(n log n)",
            "Ele pode ordenar qualquer tipo de dado"
          ],
          answer: "Ele mantém a posição relativa de elementos iguais"
        },
        {
          question: "Qual algoritmo de ordenação tem desempenho O(n²) em todos os casos e nunca melhora mesmo com listas quase ordenadas?",
          options: ["Selection Sort", "Insertion Sort", "Bubble Sort", "Gnome Sort"],
          answer: "Selection Sort"
        },
        {
          question: "Qual das seguintes alternativas descreve corretamente o funcionamento do Comb Sort?",
          options: [
            "Divide a lista em partes iguais e as ordena recursivamente",
            "Compara elementos com um 'gap' inicial e o reduz a cada iteração",
            "Seleciona o menor elemento e o coloca na primeira posição",
            "Compara e troca apenas elementos adjacentes"
          ],
          answer: "Compara elementos com um 'gap' inicial e o reduz a cada iteração"
        },
        {
          question: "Qual desses algoritmos de ordenação é mais indicado para grandes volumes de dados devido à sua eficiência média?",
          options: ["Quick Sort", "Bubble Sort", "Insertion Sort", "Selection Sort"],
          answer: "Quick Sort"
        },
        {
          question: "Inicialmente, tem-se o vetor [10, 3, 5, 8]. Após a primeira iteração, o resultado é [3, 10, 5, 8]. Qual foi o algoritmo de ordenação utilizado?",
          options: ["Insertion Sort", "Selection Sort", "Bubble Sort", "Quick Sort", "Comb Sort"],
          answer: "Selection Sort"
        },
      ];

      function renderQuiz() {
        quizContainer.innerHTML = quizQuestions.map((q, index) => `
                    <div class="mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50 shadow-md">
                        <p class="font-bold text-gray-800 mb-3">${index + 1}. ${q.question}</p>
                        <div class="space-y-2">
                            ${q.options.map((option, optIndex) => `
                                <label class="flex items-center text-gray-600 cursor-pointer hover:text-purple-600 transition-colors">
                                    <input type="radio" name="question-${index}" value="${option}" class="text-purple-600 focus:ring-purple-500 mr-2">
                                    ${option}
                                </label>
                            `).join('')}
                        </div>
                    </div>
                `).join('');
      }

      function checkQuiz() {
        let score = 0;
        let totalQuestions = quizQuestions.length;
        quizQuestions.forEach((q, index) => {
          const selected = document.querySelector(`input[name="question-${index}"]:checked`);
          const questionDiv = document.querySelector(`input[name="question-${index}"]`).closest('.mb-6');

          // Reset styling
          questionDiv.classList.remove('border-green-500', 'border-red-500', 'bg-green-50', 'bg-red-50');
          questionDiv.classList.add('border-gray-200', 'bg-gray-50');


          if (selected) {
            if (selected.value === q.answer) {
              score++;
              questionDiv.classList.remove('border-gray-200', 'bg-gray-50');
              questionDiv.classList.add('border-green-500', 'bg-green-50');
            } else {
              questionDiv.classList.remove('border-gray-200', 'bg-gray-50');
              questionDiv.classList.add('border-red-500', 'bg-red-50');
            }
          } else {
            // Se não for selecionado, trata como errado e aplica borda vermelha
            questionDiv.classList.remove('border-gray-200', 'bg-gray-50');
            questionDiv.classList.add('border-red-500', 'bg-red-50');
          }
        });

        // Exibir resultado
        const percentage = (score / totalQuestions) * 100;
        quizResult.classList.remove('hidden');

        let resultMessage = `Sua pontuação: ${score} de ${totalQuestions} (${percentage.toFixed(0)}%).`;

        if (percentage === 100) {
          quizResult.classList.remove('bg-yellow-100', 'text-yellow-800', 'bg-red-100', 'text-red-800');
          quizResult.classList.add('bg-green-100', 'text-green-800');
          resultMessage += ' Parabéns! Excelente domínio dos algoritmos.';
        } else if (percentage >= 60) {
          quizResult.classList.remove('bg-red-100', 'text-red-800');
          quizResult.classList.add('bg-yellow-100', 'text-yellow-800');
          resultMessage += ' Bom trabalho! Revise a complexidade dos que você errou.';
        } else {
          quizResult.classList.remove('bg-yellow-100', 'text-yellow-800');
          quizResult.classList.add('bg-red-100', 'text-red-800');
          resultMessage += ' Continue estudando! Foque nos casos de complexidade e nas características de cada um.';
        }

        quizResult.innerHTML = resultMessage;
      }

      // Renderizar o quiz e adicionar listener
      renderQuiz();
      submitQuizButton.addEventListener('click', checkQuiz);
    });
  </script>

</body>

</html>